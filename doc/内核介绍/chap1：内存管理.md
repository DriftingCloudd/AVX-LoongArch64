# 内存管理
## 物理内存管理
实现程序内存空间的访问，首要的是实现物理内存空间的分配。avx-Loongarch64 使用kalloc.c 文件负责物理内存的管理，包括内存的释放，访问上锁的控制以及内存的初始化等。
内存分配采用空闲链表的方式，空闲的页（每页大小为4096B）采用`struct run` 结构体负责页的分配与释放；该结构体实现的就是单向的空闲链表，链表的每个结点表示1个实际物理页。
其他的数据结构还有：
- `kmem`：在kalloc.c 模块中唯一定义的全局变量，用于访问空闲链表`freelist`，该链表使用上文`struct run` 结构实现。`kmem` 同时维护访问内存的自旋锁`spinlock`，以及剩余空闲页数`npage`

```c
struct {
	struct spinlock lock;
	struct run *freelist;
	uint64 npage;
} kmem;
```

内核启动，调用初始化函数kminit。它首先初始化kmem中的自旋锁，然后调用freerange() 函数将内核结束地址kernel_end 到物理内存上限的RAMSTOP之间的所有物理内存页添加到空闲列表中：
```c
void kinit() {
	initlock(&kmem.lock, "kmem");
	kmem.freelist = 0;
	kmem.npage = 0;
	freerange(kernel_end, (void *)RAMSTOP);
	printf("kernel_end: %p, RAMSTOP: %p\n", kernel_end, (void *)RAMSTOP);
}
```

`freerange()`用于将一段物理内存地址范围内的所有物理内存释放，然后加入到空闲链表中。它首先将起始地址向上取整到页的边界，然后从起始地址开始，每次增加1个页的大小，然后依次释放每个物理内存页。

`kfree()`函数用于释放1个物理的内存页。函数首先检查传入物理地址的合法性，检查通过则清空物理页的内容，填充垃圾字节，调用`run` 结构体将空页加入到空闲链表中。
`kalloc()`负责分配1个物理的内存页。如果空闲链表为空，返回`NULL` 表示分配失败；否则取出链表的头结点，清空该页的内容后返回。
`freemem_amount()` 返回当前空闲物理内存容量，返回方式为空闲页总量乘上每页的固定字节数（4096字节），返回值为物理内存的字节数。

## 虚拟内存管理
虚拟内存管理使用的工具是页表，avx-loongarch64使用PALEN=48的虚拟地址结构，意味着在64位的虚拟地址中只有低48位被使用，高16位是闲置或者用于窗口实现的。
此模式下，页表在逻辑层面上形成一个包含$2^{36}$个页表条目的大数组。
地址转换是4步的过程，页表在物理内存中以三层的树状结构进行存储，这棵树的根节点是4096字节的页，其中包括512个PTE，每个PTE都记录树的下一层级页表项的物理地址。这些下一层的每个页表项的每个PTE都引用的树的最后一层中的512个PTE。再进行地址转换过程中，如果缺少必要的4个PTE中的任意一个，分页硬件会抛出以1个页面错误异常，由操作系统负责处理这一情况

由于在执行转换过程中，CPU需要在内存中遍历页面，不断从页面载入数据，非常的浪费效率。因此为了降低从PTE中获得页面的成本，采取将页面信息缓存在TLB中的方式。
每个PTE包含一些标志位，这些标志位起到了向分页硬件说明如何处理相应的虚拟地址。
### 页表项
![](doc/内核介绍/picture/Pasted%20image%2020240520184848.png)
avx-loongarch64 采用虚双页号的设计，每一个TLB表项都可以分为2个部分：比较部分和物理部分。
TLB表项的比较部分包括：
- 存在位(E)，1比特。为1时表示TLB表项非空，可以参与查找分配
- 地址空间标志(ASID)，10比特。用于区分不同进程中相同的虚拟地址，避免进程切换时清空整个TLB带来的性能损失。操作系统为每个进程分配了唯一的ASID，TLB在进行查找时除了比对地址信息一致，还要比对ASID信息
- 全局标志位(G)，1比特。当该位为1时，查找时不进行ASID是否一致性的检查。
- 页大小(PS)，6比特。仅在MTLB中出现，用于指定大页页表的页表项存放的页大小。数值是页大小的幂指数。
- **虚双页号**，(VALEN - 13)比特。在LA64下，每个页表存放相邻的一对奇偶相邻页表信息，所以TLB页表中存放虚页号的是系统中虚页号/2 的内容，即虚页号的最低位不需要存放在TLB中。查找TLB时根据被查找虚页号的最低位决定选择时奇数号页还是偶数号页。

物理部分，PPN表示物理页号，(PALEN-12)比特，其余页表转换信息包括：
- 有效位(V)，1比特。为1表示页表项有效并且被访问过。
- 脏位(D)，1比特。为1时表示页表项对应的地址范围内有脏数据。
- 不可读位(NR)，1比特。为1时表示该页表项所在的地址空间上不允许执行load操作。
- 不可执行位(NX)，1比特。为1表示该页表项所在的地址空间上不允许执行取指操作。
- 存储访问类型(MAT)，2比特。控制落在页表项所在地址空间上访存操作的存储访问类型。
- 特权等级(PLV)，2比特。
- 受限特权等级使能(RPLV)，1比特。页表项是否仅被对应特权等级的程序访问的控制位。为0时，该页表项可以被任何特权等级不低于PLV的程序访问；当RPLV=1时，该页表项可以被等级等于PLV的程序访问。

通常，avx-loongarch64 会将所有的物理内存映射到页表中，这样它就可以使用`load/store`指令读取和写入物理内存。

### 虚存管理函数
虚存的管理函数主要用于分页和内存映射，在模块`vm.c`中定义的函数主要执行内存分页、页表创建和管理，虚拟地址和物理地址之间的映射和反映等操作。
函数定义内容如下：
- `kminit()`：创建一个直接映射的页表用于内核。在函数中，首先给页表分配空间，使用无意义的数据做初始化。然后，建立内核与其他设备的映射，如UART寄存器，从而使内核通过映射的虚拟地址访问这些设备
- `kvminithart`：将硬件的页表寄存器设置为内核的页表，刷新页表。
- `walk()`：返回对于给定的虚拟地址的页表项的地址，如果参数`alloc = 1`则会为没有分配的虚拟地址分配页表
- `walkaddr()`：返回给定虚拟地址的物理地址，只工作在用户态下。
- `kvmmap()`：函数实现向内核页表添加一个映射，只在内核启动时调用。
- `kvmpa()`：用于将内核的虚拟地址转换为物理地址
- `mappages()`：为从传入虚拟地址`va`处创建页表项，这些页表项必须指向从`pa`开始的物理地址；允许`va`页不对齐。
- `vmunmap()`：这个函数负责取消从`va`开始的npages页的映射关系，根据参数`do_free`是否为真同时释放内存
- `uvminit()`：将用户的初始代码加载到页表的地址0处。
- `uvmalloc1()`：函数负责从`start`到`end`的虚拟地址分配PTE和物理内存，失败返回-1

以下是对页表的更精细化的操作：
- `freewalk`：这个函数遍历页表，递归地释放所有子页表
- `uvmfree()`：先释放用户内存，再释放页表项
- `uvmcopy`：复制父进程的页表项和物理内存到子进程的页表中
- `uvmclear`：将指定的虚拟地址的页表项标记为用户无法访问，设置特权级障碍
- `copyout()`：负责从内核复制数据到用户空间
- `copyout2()`：`copyout()`的简化版本，直接在虚拟地址空间操作
- `copyin()`：从用户空间复制数据到内核
- `copyin2()`：`copyin`的简化版本
- `copyinstr`：从用户空间复制一个字符串到内核
- `copyinstr2`：`copyinstr`的简化版本，直接在虚拟地址空间操作
- `proc_kpageytable`：初始化每个进程的内核页表
- `kfreewalk()`：释放页表的内核空间
- `kfreeuser()`：释放用户页表的内核空间，通过调用`kfreewalk()`实现
- `kvmfree()`：释放整个内核页表
- `experm`：改变制定虚拟地址的页表项的权限

页表的权限管理、地址空间管理、分页映射等功能就通过上述的函数模块实现。每个进程都具有独立的页表，用户与映射其虚拟地址空间到物理内存中。每个进程的用户内存从0开始，逐步增长到上界MAXUVA。
 
![](doc/内核介绍/picture/Pasted%20image%2020240521183010.png)
