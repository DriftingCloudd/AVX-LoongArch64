## 指令字



# 存储管理系统
存储管理首要的是特权级别的实现，RISC-V采用传统的用户态， 监管态，机器态以及虚拟化模式（可选）实现特权分级，相比之下，Loongarch 架构在虚拟化模式之外采用PLV0-PLV3的特权等级，使用PLV0表示核心态，拥有特权控制命令的权限；一般使用PLV3表示用户态。

PLV1-3都没有使用特权控制命令的权限，3者的区别在于映射翻译模式下的权限不同。Loongarch 架构的MMU采用2种翻译模式，分别是**直接翻译模式** 和 **映射翻译模式**；在直接翻译模式下，如对IOCSR 的控制，物理地址等同于虚拟地址的低$[PALEN-1:0]$位。

翻译模式的选择由CSR中CRMD域选择控制：
- DA=1,PG=0,直接地址翻译模式
- DA=1,PG=1,映射地址翻译模式

## 物理页分配空间
使用$PALEN$表示物理地址最大值，在LA64架构下，$PALEN$ 大小不超过60, 高大于等于4位空间用于执行地址映射。

## 映射地址翻译模式
映射地址翻译模式分为：直接映射地址翻译模式和**页表地址翻译模式**，目前采用的是LA64架构下的直接映射翻译模式。该模式下，Loongarch架构存在4个**映射窗口**：DWM0-DWM3。前2个窗口可用于load/store 操作和 *取指操作*， 后2个窗口用于load/store 操作。

明显，每种窗口匹配的大小是$2^{PALEN}$，高位用于判断命中哪一种映射窗口，从而将在页表映射不合法的虚地址映射到物理地址空间中。

![](assets/Pasted%20image%2020240508170929.png)

## 页表
Loongarch 架构下的页表分为比较部分和物理转换部分，如下图所示：
![](assets/Pasted%20image%2020240508182241.png)

VPPN：虚双页号。在龙芯架构中,每一个页表项存放了**相邻的一对奇偶相邻页**表信息,所以 TLB 页表项中存放虚页号的是系统中虚页号/2 的内容,即虚页号的最低位不需要存放在 TLB 中。查找 TLB 时在根据被查找虚页号的最低位决定是选择奇数号页还是偶数号页的物理转换信息。

**在RISC-V**架构下，采用 *传统的单页表模式*， 每个页表项存储了一个虚拟页号到物理页号的映射关系。有这样的区别，Loongarch 的单页表项实际对应2个物理页，也如上所示。

## 物理转换部分
页表掩码在虚存映射，如`walk` 函数或页表初始化的权限设置都起限制作用。从上图中不难看出Loongarch架构下掩码分别为：

| 掩码类型 | 作用                                 |
| ---- | ---------------------------------- |
| RPLV | 受限特权等级使能，页表项是否*仅* 被对应特权等级的程序访问的控制位 |
| PLV  | 特权级别                               |
| MAT  | 存储访问类型                             |
| NX   | 不可执行                               |
| NR   | 不可读                                |
| D    | 脏位，同 RISCV                         |
| V    | 有效位，同 RISCV                        |
| P    | 物理页存在                              |
| W    | 可写                                 |

类似的，RISC-V主要掩码分别为：

| 掩码类型 | 作用                  |
| ---- | ------------------- |
| V    | 有效位                 |
| R    | 可读                  |
| W    | 可写                  |
| X    | 可执行                 |
| U    | 特权等级为用户态            |
| G    | 表示全局页面              |
| A    | 表示页面是否被访问过（ACCESSD） |
| D    | 脏位                  |
### 掩码位置
根据Loongarch 页表权限设置的位置不同，将掩码分为低位掩码和高位掩码，以LA64 基本页表模式（与大页区分）举例：
![](assets/Pasted%20image%2020240508185358.png)

在掩码基础上，两种架构判断页表项是否是非页子结点的空项的方式可以不同：


| RISC-V                                                    | Loongarch                                    |
| --------------------------------------------------------- | -------------------------------------------- |
| `(pte & PTE_V) && (pte & (PTE_R \| PTE_W \| PTE_X)) == 0` | `(pte & PTE_V) && (PTE_FLAGS(pte) == PTE_V)` |

### 页表数
采用页表映射翻译模式时，根据实际页表层数查询。RISC-V `Rv39` 页表结构采用三级页表，Loongarch 架构采用4级页表：

![](assets/Pasted%20image%2020240508185805.png)

## 比较部分
除VPPN(虚双页号外), TLB比较部分表相包括:
- PS: 在大页表中存在, 用于表示页大小
- ASID: 地址空间标志, **10bit**. 标识区分不同进程中同样的虚地址,避免进程切换时清空整个TLB 所带来的性能损失. 实现方式是为每个进程分配唯一的ASID.
- G: 全局标志位, 当G=1时,查找时不进行ASID 是否一致性的检查, 用于将所有进程设置为共享同一虚拟地址.
- E: 存在位, 表示TLB表项非空


# 中断控制系统

## 异常与中断 

计算机通常按照软件的执行流进行顺序执行和跳转，但有时会需要中断正常的执行流程去处理其他任务，可以触发这一过程的事件统称为异常。

### 异常分类

从来源来看，异常可分为以下6种。

1）外部事件：来自CPU核外部的事件，来自处理器内部其他模块或者处理器外部的真实物理连线也称为中断。中断的存在使得CPU能够异步地处理多个事件。在操作系统中，为了避免轮询等待浪费CPU时间，与IO相关的任务通常都会用中断方式进行处理。中断事件的发生往往是软件不可控制的，因此需要一套健全的软硬件机制来防止中断对正常执行流带来影响。

2）指令执行中的错误：执行中的指令的操作码或操作数不符合要求，例如不存在的指令、除法除以0、地址不对齐、用户态下调用核心态专有指令或非法地址空间访问等。这些错误使得当前指令无法继续执行，应当转到出错处进行处理。

3）数据完整性问题：当使用ECC等硬件校验方式的存储器发生校验错误时，会产生异常。可纠正的错误可用于统计硬件的风险，不可纠正的错误则应视出错位置进行相应处理。

4）地址转换异常：在存储管理单元需要对一个内存页进行地址转换，而硬件转换表中没有有效的转换对应项可用时，会产生地址转换异常。

5）系统调用和陷入：由专有指令产生，其目的是产生操作系统可识别的异常，用于在保护模式下调用核心态的相关操作。

6）需要软件修正的运算：常见的是浮点指令导致的异常，某些操作和操作数的组合硬件由于实现过于复杂而不愿意处理，寻求软件的帮助。

下表列举了LoongArch指令系统中主要的异常。

| 异常代号   | Ecode   | Esubcode   | 异常说明                    | 所属异常类别       |
|:-----------|:--------|:-----------|:----------------------------|:-------------------|
| PIL        | 0x1     |            | load操作页无效异常          | 地址转换异常       |
| PIS        | 0x2     |            | store操作页无效异常         | 地址转换异常       |
| PIF        | 0x3     |            | 取指操作页无效异常          | 地址转换异常       |
| PME        | 0x4     |            | 页修改异常                  | 地址转换异常       |
| PNR        | 0x5     |            | 页不可读异常                | 地址转换异常       |
| PNX        | 0x6     |            | 页不可执行异常              | 地址转换异常       |
| PPI        | 0x7     |            | 页权限等级不合规异常        | 地址转换异常       |
| ADEF       | 0x8     | 0x0        | 取指地址错异常              | 指令执行中的错误   |
| ADEM       | 0x8     | 0x1        | 访存指令地址错异常          | 指令执行中的错误   |
| ALE        | 0x9     |            | 地址非对齐异常              | 指令执行中的错误   |
| BCE        | 0xA     |            | 边界约束检查错异常          | 指令执行中的错误   |
| SYS        | 0xB     |            | 系统调用异常                | 系统调用和陷入     |
| BRK        | 0xC     |            | 断点异常                    | 系统调用和陷入     |
| INE        | 0xD     |            | 指令不存在异常              | 指令执行中的错误   |
| IPE        | 0xE     |            | 指令权限等级错异常          | 指令执行中的错误   |
| FPD        | 0xF     |            | 浮点指令未使能异常          | 系统调用和陷入     |
| SXD        | 0x10    |            | 128位向量扩展指令未使能异常 | 系统调用和陷入     |
| ASXD       | 0x11    |            | 256位向量扩展指令未使能异常 | 系统调用和陷入     |
| FPE        | 0x12    | 0x0        | 基础浮点指令异常            | 需要软件修正的运算 |
| VFPE       | 0x12    | 0x1        | 向量浮点指令异常            | 需要软件修正的运算 |
| WPEF       | 0x13    | 0x0        | 取指监测点异常              | 系统调用和陷入     |
| WPEM       | 0x13    | 0x1        | load/store操作监测点异常    | 系统调用和陷入     |
| INT        |         |            | 中断                        | 外部事件           |
| TLBR       |         |            | TLB重填异常                 | 地址转换异常       |
| MERR       |         |            | 机器错误异常                | 数据完整性问题     |


### 异常处理

#### 异常处理流程

异常处理的流程包括异常处理准备、确定异常来源、保存执行状态、处理异常、恢复执行状态并返回等。主要内容是确定并处理异常，同时正确维护上下文环境。异常处理是一个软硬件协同的过程，通常CPU硬件需要维护一系列控制状态寄存器（域）以用于软硬件之间的交互。LoongArch指令系统中与异常（含中断）处理相关的控制状态寄存器格式如图所示。

![alt text](./assets/image.png)

下面对异常处理流程的五个阶段进行介绍。

1）异常处理准备。当异常发生时，CPU在转而执行异常处理前，硬件需要进行一系列准备工作。

首先，需要记录被异常打断的指令的地址（记为EPTR）。LoongArch存于CSR.ERA中，特别地，当TLB重填异常发生时，这一信息将被记录在CSR.TLBRBERA中;机器错误异常发生时，这一信息将被记录在CSR.MERRERA中。

其次，调整CPU的权限等级（通常调整至最高特权等级）并关闭中断响应。在LoongArch指令系统中，当异常发生时，硬件会将CSR.CRMD的PLV域置0以进入最高特权等级，并将CSR.CRMD的IE域置0以屏蔽所有中断输入。

再次，硬件保存异常发生现场的部分信息。在LoongArch指令系统中，异常发生时会将CSR.CRMD中的PLV和IE域的旧值分别记录到CSR.PRMD的PPLV和PIE域中，供后续异常返回时使用。

最后，记录异常的相关信息。异常处理程序将利用这些信息完成或加速异常的处理。最常见的如记录异常编号以用于确定异常来源。在LoongArch指令系统中，这一信息将被记录在CSR.ESTAT的Ecode和EsubCode域，前者存放异常的一级编号，后者存放异常的二级编号。除此以外，有些情况下还会将引发异常的指令的机器码记录在CSR.BADI中，或是将造成异常的访存虚地址记录在CSR.BADV中。

2）确定异常来源。不同类型的异常需要各自对应的异常处理。处理器确定异常来源主要有两种方式：一种是将不同的异常进行编号，异常处理程序据此进行区分并跳转到指定的处理入口；另一种是为不同的异常指定不同的异常处理程序入口地址，这样每个入口处的异常处理程序自然知晓待处理的异常来源。LoongArch将不同的异常进行编号，其异常处理程序入口地址采用“入口页号与页内偏移进行按位逻辑或”的计算方式，入口页号通过CSR.EENTRY配置，每个普通异常处理程序入口页内偏移是其异常编号乘以一个可配置间隔（通过CSR.ECFG的VS域配置）。通过合理配置EENTRY和ECFG控制状态寄存器中相关的域，可以使得不同异常处理程序入口地址不同。当然，也可以通过配置使得所有异常处理程序入口为同一个地址，但是实际使用中通常不这样处理。

3）保存执行状态。在操作系统进行异常处理前，软件要先保存被打断的程序状态，通常至少需要将通用寄存器和程序状态字寄存器的值保存到栈中。

4）处理异常。跳转到对应异常处理程序进行异常处理。

5）恢复执行状态并返回。在异常处理返回前，软件需要先将前面第3个步骤中保存的执行状态从栈中恢复出来，在最后执行异常返回指令。之所以要采用专用的异常返回指令，是因为该指令需要原子地完成恢复权限等级、恢复中断使能状态、跳转至异常返回目标等多个操作。在LoongArch中，异常返回的指令是ERTN，该指令会将CSR.PRMD的PPLV和PIE域分别回填至CSR.CRMD的PLV和IE域，从而使得CPU的权限等级和全局中断响应状态恢复到异常发生时的状态，同时该指令还会将CSR.ERA中的值作为目标地址跳转过去。

#### 异常嵌套

在LoongArch指令系统中，异常嵌套时被打断的异常处理程序的状态的保存和恢复主要交由软件处理，这就需要保证异常处理程序在完成当前上下文的保存操作之前，不会产生新的异常，或者产生的新异常不会修改当前需要保存的上下文。


### 中断

异常处理的流程是通用的，但有两类异常出现的机会确实比其他类型大很多。一类是地址转换异常，当片内从虚地址到物理地址的地址转换表不包含访问地址时，就会产生缺页异常。另一类常见的异常就是中断，中断在外部事件想要获得CPU注意时产生。由于外部事件的不可控性，中断处理所用的时间较为关键。

#### 中断传递机制

中断从系统中各个中断源传递到处理器主要有两种形式：中断线和消息中断。

用中断线传递是最简便直接的方式。当系统的中断源不多时，直接连到处理器引脚即可。若中断源较多，可使用中断控制器汇总后再与处理器引脚相连。由于连线会占用引脚资源，一般只在片上系统(System On Chip,简称SoC)中才会给每个外设连接单独的中断线，板级的中断线一般采用共享的方式。比如PCI上有四根中断线，供所有的设备共享。中断处理程序在定位到哪根中断线发生中断后，逐个调用注册在该中断线的设备中断服务。

LoongArch指令系统支持中断线的中断传递机制，共定义了13个中断，分别是：1个核间中断（IPI），1个定时器中断（TI），1个性能监测计数溢出中断（PMI），8个外部硬中断（HWI0\~HWI7），2个软中断（SWI0\~SWI1）。其中所有中断线上的中断信号都采用电平中断，且都是高电平有效。当有中断发生时，这种高电平有效中断方式输入给处理器的中断线上将维持高电平状态直至中断被处理器响应处理。无论中断源来自处理器核外部还是内部，是硬件还是软件置位，这些中断信号都被不间断地采样并记录到CSR.ESTAT中IS域的对应比特位上。这些中断均为可屏蔽中断，除了CSR.CRMD中的全局中断使能位IE外，每个中断各自还有其局部中断使能控制位，在CSR.ECFG的LIE域中。当CSR.ESTAT中IS域的某位为1且对应的局部中断使能和全局中断使能均有效时，处理器就将响应该中断，并进入中断处理程序入口处开始执行。


#### 向量化中断

LoongArch指令系统默认支持向量化中断，其13个线中断各自具有独立的中断处理程序入口地址。在LoongArch指令系统中，中断被视作一类特殊的异常进行处理，因此在具体计算中断处理程序入口地址时将SWI0～IPI这13个中断依次“视作”异常编号64～76的异常，用异常处理程序入口地址的统一计算方式进行计算。



#### 中断的优先级

在支持多个中断源输入的指令系统中，需要规范在多个中断同时触发的情况下，处理器是否区别不同来源的中断的优先级。当采用非向量中断模式的时候，处理器通常不区别中断优先级，此时若需要对中断进行优先级处理，可以通过软件方式予以实现，其通常的实现方案是：

1）软件随时维护一个中断优先级（IPL），每个中断源都被赋予特定的优先级。

2）正常状态下，CPU运行在最低优先级，此时任何中断都可触发。

3）当处于最高中断优先级时，任何中断都被禁止。

4）更高优先级的中断发生时，可以抢占低优先级的中断处理过程。

当采用向量中断模式的时候，处理器通常不可避免地需要依照一套既定的优先级规则来从多个已生效的中断源中选择一个，跳转到其对应的处理程序入口处。LoongArch指令系统实现的是向量中断，采用固定优先级仲裁机制，具体规则是硬件中断号越大优先级越高，即IPI的优先级最高，TI次之，…，SWI0的优先级最低。

#### 中断使能控制位的原子修改

在中断处理程序中，经常会涉及中断使能控制位的修改，如关闭、开启全局中断使能。在大多数指令系统中，这些中断使能控制位位于控制状态寄存器中，因此软件在进行中断使能控制调整时，必须关注修改的原子性问题。以LoongArch指令系统为例，全局中断使能控制位IE位于CRMD控制寄存器的第2位。如果仅用CSRRD和CSRWR指令访问CRMD控制寄存器，那么需要通过下面的一段程序才能完成开启中断使能的功能：

```        
    li		$t1, IE_BITMASK
    csrrd	$t0, CSR_CRMD
1:
    andn	$t0, $t0, $t1
    or		$t0, $t0, $t1
2:
    csrwr	$t0, CSR_CRMD
```

这段程序本身也可能被中断，若在标号1和2之间被中断且中断处理程序修改了CRMD控制寄存器的值，则在返回时该中断处理程序对CRMD控制寄存器的改写会被这段程序覆盖。若不想让这种情况发生，就需要保证这段程序不会被打断，更正式地说是保证这段程序的原子性。保证原子性的方法有很多种，例如添加专门的位原子修改指令、在程序执行时禁用中断、不允许中断处理程序修改SR，或者使用通用的方法保证程序段的原子性，即将被访问的控制寄存器作为临界区来考虑。LoongArch指令系统中定义了按位掩码修改控制寄存器的指令CSRXCHG。使用该指令时，上述开启全局中断使能的代码改写如下：

```
    li		 $t0, IE_BITMASK
    csrxchg	 $t0, $t0, CSR_CRMD
```

上面的例子中，CRMD寄存器的IE位置1的操作仅通过csrxchg一条指令完成，所以自然确保了修改的原子性。

## 与RSICV的比较

### 异常和中断编码（Ecode和Esubcode）
LoongArch: LoongArch在其控制状态寄存器CSR中使用Ecode和Esubcode字段来明确指示异常和中断的具体类型。Ecode表示一级异常或中断编号，而Esubcode提供了额外的细分信息，这使得异常处理更加精确和清晰。

RISC-V: RISC-V使用单一的mcause寄存器来编码中断和异常。中断被标识为mcause的最高位设置为1，而具体的异常或中断类型则由其余位表示。这种方法简化了寄存器的使用，但可能在某些情况下不如LoongArch的方法那么直观明确。

### 向量化中断处理

LoongArch: LoongArch支持向量化中断，每个中断类型可以有其独立的处理程序入口地址，这减少了处理中断时的开销，因为不需要在中断处理程序中进一步解析中断类型。这种设计优化了中断响应时间和处理效率。

RISC-V: 标准RISC-V也支持向量化中断，但这是可选的，并且实现依赖于具体的硬件配置。不同于LoongArch的是，RISC-V通常需要额外的硬件支持来实现类似功能。

### 控制状态寄存器和系统寄存器的使用

LoongArch: LoongArch指令集架构中，异常和中断处理广泛使用了控制状态寄存器（CSR），例如CRMD、ESTAT等。这些寄存器存储了异常处理所需的各种状态信息，使得状态管理和上下文切换更加高效。

RISC-V: RISC-V使用的是机器模式寄存器（如mstatus, mepc, mtvec, mcause等），这些寄存器在功能上类似于LoongArch的CSR，但在名字和某些细节上有所不同。RISC-V的设计更注重简洁性和模块化。

### 异常和中断的优先级处理

LoongArch: LoongArch的中断优先级是固定的，中断号越大优先级越高。这种固定的优先级仲裁机制简化了硬件的设计，但可能在某些应用场景下减少了灵活性。

RISC-V: 在RISC-V中，中断优先级的处理可以通过外部中断控制器来实现，例如使用PLIC（Platform-Level Interrupt Controller）。这提供了更高的灵活性，使得系统可以根据需要调整中断优先级。
### 中断使能控制位的原子修改

LoongArch: LoongArch提供了CSRXCHG指令，允许原子性地修改控制寄存器中的位，这对于中断使能控制非常关键。这样的设计可以在不禁用中断的情况下安全地修改中断使能位。

RISC-V: 在RISC-V中，修改中断使能通常需要通过读-修改-写操作来完成，涉及到多个步骤。虽然有一些扩展（如A扩展）提供原子操作支持，但这不是所有RISC-V实现都必须的。
