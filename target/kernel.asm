
target/kernel:     file format elf64-loongarch


Disassembly of section .text:

9000000008000000 <_entry>:
9000000008000000:	0320000c 	lu52i.d	$r12,$r0,-2048(0x800)
9000000008000004:	0406002c 	csrwr	$r12,0x180
9000000008000008:	0380440c 	ori	$r12,$r0,0x11
900000000800000c:	0324018c 	lu52i.d	$r12,$r12,-1792(0x900)
9000000008000010:	0406042c 	csrwr	$r12,0x181
9000000008000014:	0402202c 	csrwr	$r12,0x88
9000000008000018:	0382c00c 	ori	$r12,$r0,0xb0
900000000800001c:	0400002c 	csrwr	$r12,0x0
9000000008000020:	0015000c 	move	$r12,$r0
9000000008000024:	0400042c 	csrwr	$r12,0x1
9000000008000028:	0015000c 	move	$r12,$r0
900000000800002c:	0400082c 	csrwr	$r12,0x2
9000000008000030:	1c0000a3 	pcaddu12i	$r3,5(0x5)
9000000008000034:	28ffe063 	ld.d	$r3,$r3,-8(0xff8)
9000000008000038:	14000024 	lu12i.w	$r4,1(0x1)
900000000800003c:	04008005 	csrrd	$r5,0x20
9000000008000040:	02c000a2 	addi.d	$r2,$r5,0
9000000008000044:	02c004a5 	addi.d	$r5,$r5,1(0x1)
9000000008000048:	001d9484 	mul.d	$r4,$r4,$r5
900000000800004c:	00109063 	add.d	$r3,$r3,$r4
9000000008000050:	540c1400 	bl	3092(0xc14) # 9000000008000c64 <main>

9000000008000054 <spin>:
9000000008000054:	50000000 	b	0 # 9000000008000054 <spin>

9000000008000058 <printstring>:
static struct {
  struct spinlock lock;
  int locking;
} pr;

void printstring(const char *s) {
9000000008000058:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
900000000800005c:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008000060:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008000064:	29c02077 	st.d	$r23,$r3,8(0x8)
9000000008000068:	02c08076 	addi.d	$r22,$r3,32(0x20)
900000000800006c:	00150097 	move	$r23,$r4
  while (*s) {
9000000008000070:	28000084 	ld.b	$r4,$r4,0
9000000008000074:	40001480 	beqz	$r4,20(0x14) # 9000000008000088 <printstring+0x30>
    consputc(*s++);
9000000008000078:	02c006f7 	addi.d	$r23,$r23,1(0x1)
900000000800007c:	540cc400 	bl	3268(0xcc4) # 9000000008000d40 <consputc>
  while (*s) {
9000000008000080:	280002e4 	ld.b	$r4,$r23,0
9000000008000084:	47fff49f 	bnez	$r4,-12(0x7ffff4) # 9000000008000078 <printstring+0x20>
  }
}
9000000008000088:	28c06061 	ld.d	$r1,$r3,24(0x18)
900000000800008c:	28c04076 	ld.d	$r22,$r3,16(0x10)
9000000008000090:	28c02077 	ld.d	$r23,$r3,8(0x8)
9000000008000094:	02c08063 	addi.d	$r3,$r3,32(0x20)
9000000008000098:	4c000020 	jirl	$r0,$r1,0

900000000800009c <printint>:

void printint(int xx, int base, int sign) {
900000000800009c:	02ff4063 	addi.d	$r3,$r3,-48(0xfd0)
90000000080000a0:	29c0a061 	st.d	$r1,$r3,40(0x28)
90000000080000a4:	29c08076 	st.d	$r22,$r3,32(0x20)
90000000080000a8:	29c06077 	st.d	$r23,$r3,24(0x18)
90000000080000ac:	29c04078 	st.d	$r24,$r3,16(0x10)
90000000080000b0:	02c0c076 	addi.d	$r22,$r3,48(0x30)
  char buf[16];
  int i;
  uint x;

  if (sign && (sign = xx < 0))
90000000080000b4:	400008c0 	beqz	$r6,8(0x8) # 90000000080000bc <printint+0x20>
90000000080000b8:	60001c80 	blt	$r4,$r0,28(0x1c) # 90000000080000d4 <printint+0x38>
    x = -xx;
  else
    x = xx;
90000000080000bc:	00150011 	move	$r17,$r0
90000000080000c0:	02ff42cd 	addi.d	$r13,$r22,-48(0xfd0)

  i = 0;
90000000080000c4:	0015000f 	move	$r15,$r0
  do {
    buf[i++] = digits[x % base];
90000000080000c8:	1c000070 	pcaddu12i	$r16,3(0x3)
90000000080000cc:	02fe6210 	addi.d	$r16,$r16,-104(0xf98)
90000000080000d0:	50001800 	b	24(0x18) # 90000000080000e8 <printint+0x4c>
    x = -xx;
90000000080000d4:	00111004 	sub.w	$r4,$r0,$r4
  if (sign && (sign = xx < 0))
90000000080000d8:	02800411 	addi.w	$r17,$r0,1(0x1)
    x = -xx;
90000000080000dc:	53ffe7ff 	b	-28(0xfffffe4) # 90000000080000c0 <printint+0x24>
  } while ((x /= base) != 0);
90000000080000e0:	00150184 	move	$r4,$r12
    buf[i++] = digits[x % base];
90000000080000e4:	001501cf 	move	$r15,$r14
90000000080000e8:	028005ee 	addi.w	$r14,$r15,1(0x1)
90000000080000ec:	0021948c 	mod.wu	$r12,$r4,$r5
90000000080000f0:	5c0008a0 	bne	$r5,$r0,8(0x8) # 90000000080000f8 <printint+0x5c>
90000000080000f4:	002a0007 	break	0x7
90000000080000f8:	00df018c 	bstrpick.d	$r12,$r12,0x1f,0x0
90000000080000fc:	0010b20c 	add.d	$r12,$r16,$r12
9000000008000100:	2a00018c 	ld.bu	$r12,$r12,0
9000000008000104:	290001ac 	st.b	$r12,$r13,0
  } while ((x /= base) != 0);
9000000008000108:	0021148c 	div.wu	$r12,$r4,$r5
900000000800010c:	5c0008a0 	bne	$r5,$r0,8(0x8) # 9000000008000114 <printint+0x78>
9000000008000110:	002a0007 	break	0x7
9000000008000114:	02c005ad 	addi.d	$r13,$r13,1(0x1)
9000000008000118:	6fffc885 	bgeu	$r4,$r5,-56(0x3ffc8) # 90000000080000e0 <printint+0x44>

  if (sign)
900000000800011c:	40001a20 	beqz	$r17,24(0x18) # 9000000008000134 <printint+0x98>
    buf[i++] = '-';
9000000008000120:	02ff82cc 	addi.d	$r12,$r22,-32(0xfe0)
9000000008000124:	0010b98e 	add.d	$r14,$r12,$r14
9000000008000128:	0280b40c 	addi.w	$r12,$r0,45(0x2d)
900000000800012c:	293fc1cc 	st.b	$r12,$r14,-16(0xff0)
9000000008000130:	028009ee 	addi.w	$r14,$r15,2(0x2)

  while (--i >= 0)
9000000008000134:	6400340e 	bge	$r0,$r14,52(0x34) # 9000000008000168 <printint+0xcc>
9000000008000138:	02ff82cc 	addi.d	$r12,$r22,-32(0xfe0)
900000000800013c:	0010b997 	add.d	$r23,$r12,$r14
9000000008000140:	02ffbef7 	addi.d	$r23,$r23,-17(0xfef)
9000000008000144:	02ff3ad8 	addi.d	$r24,$r22,-50(0xfce)
9000000008000148:	0010bb18 	add.d	$r24,$r24,$r14
900000000800014c:	02bffdce 	addi.w	$r14,$r14,-1(0xfff)
9000000008000150:	00df01ce 	bstrpick.d	$r14,$r14,0x1f,0x0
9000000008000154:	0011bb18 	sub.d	$r24,$r24,$r14
    consputc(buf[i]);
9000000008000158:	280002e4 	ld.b	$r4,$r23,0
900000000800015c:	540be400 	bl	3044(0xbe4) # 9000000008000d40 <consputc>
9000000008000160:	02fffef7 	addi.d	$r23,$r23,-1(0xfff)
  while (--i >= 0)
9000000008000164:	5ffff6f8 	bne	$r23,$r24,-12(0x3fff4) # 9000000008000158 <printint+0xbc>
}
9000000008000168:	28c0a061 	ld.d	$r1,$r3,40(0x28)
900000000800016c:	28c08076 	ld.d	$r22,$r3,32(0x20)
9000000008000170:	28c06077 	ld.d	$r23,$r3,24(0x18)
9000000008000174:	28c04078 	ld.d	$r24,$r3,16(0x10)
9000000008000178:	02c0c063 	addi.d	$r3,$r3,48(0x30)
900000000800017c:	4c000020 	jirl	$r0,$r1,0

9000000008000180 <backtrace>:
  panicked = 1; // freeze uart output from other CPUs
  for (;;)
    ;
}

void backtrace() {
9000000008000180:	02ff4063 	addi.d	$r3,$r3,-48(0xfd0)
9000000008000184:	29c0a061 	st.d	$r1,$r3,40(0x28)
9000000008000188:	29c08076 	st.d	$r22,$r3,32(0x20)
900000000800018c:	29c06077 	st.d	$r23,$r3,24(0x18)
9000000008000190:	29c04078 	st.d	$r24,$r3,16(0x10)
9000000008000194:	29c02079 	st.d	$r25,$r3,8(0x8)
9000000008000198:	02c0c076 	addi.d	$r22,$r3,48(0x30)

static inline uint64
r_fp()
{
  uint64 x;
  asm volatile("addi.d %0, $fp, 0" : "=r" (x) );
900000000800019c:	02c002d8 	addi.d	$r24,$r22,0
  uint64 *fp = (uint64 *)r_fp();
90000000080001a0:	00150317 	move	$r23,$r24
  uint64 *bottom = (uint64 *)PGROUNDUP((uint64)fp);
90000000080001a4:	03bffc0c 	ori	$r12,$r0,0xfff
90000000080001a8:	0010b318 	add.d	$r24,$r24,$r12
90000000080001ac:	15ffffec 	lu12i.w	$r12,-1(0xfffff)
90000000080001b0:	0014b318 	and	$r24,$r24,$r12
  printf("backtrace:\n");   //这个地方原本使用的是serious_print()
90000000080001b4:	1c000064 	pcaddu12i	$r4,3(0x3)
90000000080001b8:	02f93084 	addi.d	$r4,$r4,-436(0xe4c)
90000000080001bc:	5400b400 	bl	180(0xb4) # 9000000008000270 <printf>
  while (fp < bottom) {
90000000080001c0:	6c0026f8 	bgeu	$r23,$r24,36(0x24) # 90000000080001e4 <backtrace+0x64>
    uint64 ra = *(fp - 1);
    printf("%p\n", ra - 4);     //同上
90000000080001c4:	1c000079 	pcaddu12i	$r25,3(0x3)
90000000080001c8:	02f93339 	addi.d	$r25,$r25,-436(0xe4c)
90000000080001cc:	28ffe2e5 	ld.d	$r5,$r23,-8(0xff8)
90000000080001d0:	02fff0a5 	addi.d	$r5,$r5,-4(0xffc)
90000000080001d4:	00150324 	move	$r4,$r25
90000000080001d8:	54009800 	bl	152(0x98) # 9000000008000270 <printf>
    fp = (uint64 *)*(fp - 2);
90000000080001dc:	28ffc2f7 	ld.d	$r23,$r23,-16(0xff0)
  while (fp < bottom) {
90000000080001e0:	6bffeef8 	bltu	$r23,$r24,-20(0x3ffec) # 90000000080001cc <backtrace+0x4c>
  }
}
90000000080001e4:	28c0a061 	ld.d	$r1,$r3,40(0x28)
90000000080001e8:	28c08076 	ld.d	$r22,$r3,32(0x20)
90000000080001ec:	28c06077 	ld.d	$r23,$r3,24(0x18)
90000000080001f0:	28c04078 	ld.d	$r24,$r3,16(0x10)
90000000080001f4:	28c02079 	ld.d	$r25,$r3,8(0x8)
90000000080001f8:	02c0c063 	addi.d	$r3,$r3,48(0x30)
90000000080001fc:	4c000020 	jirl	$r0,$r1,0

9000000008000200 <panic>:
void panic(char *s) {
9000000008000200:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008000204:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008000208:	29c04076 	st.d	$r22,$r3,16(0x10)
900000000800020c:	29c02077 	st.d	$r23,$r3,8(0x8)
9000000008000210:	02c08076 	addi.d	$r22,$r3,32(0x20)
9000000008000214:	00150097 	move	$r23,$r4
  if (strncmp(s, "No futex Resource!", 18) == 0) {
9000000008000218:	02804806 	addi.w	$r6,$r0,18(0x12)
900000000800021c:	1c000065 	pcaddu12i	$r5,3(0x3)
9000000008000220:	02f7f0a5 	addi.d	$r5,$r5,-516(0xdfc)
9000000008000224:	54073c00 	bl	1852(0x73c) # 9000000008000960 <strncmp>
  printf("%p\n", s);  // 这个地方原本使用的是serious_print
9000000008000228:	001502e5 	move	$r5,$r23
900000000800022c:	1c000064 	pcaddu12i	$r4,3(0x3)
9000000008000230:	02f79084 	addi.d	$r4,$r4,-540(0xde4)
9000000008000234:	54003c00 	bl	60(0x3c) # 9000000008000270 <printf>
  printf("panic: ");
9000000008000238:	1c000064 	pcaddu12i	$r4,3(0x3)
900000000800023c:	02f7e084 	addi.d	$r4,$r4,-520(0xdf8)
9000000008000240:	54003000 	bl	48(0x30) # 9000000008000270 <printf>
  printf(s);
9000000008000244:	001502e4 	move	$r4,$r23
9000000008000248:	54002800 	bl	40(0x28) # 9000000008000270 <printf>
  printf("\n");
900000000800024c:	1c000064 	pcaddu12i	$r4,3(0x3)
9000000008000250:	02f7b084 	addi.d	$r4,$r4,-532(0xdec)
9000000008000254:	54001c00 	bl	28(0x1c) # 9000000008000270 <printf>
  backtrace();
9000000008000258:	57ff2bff 	bl	-216(0xfffff28) # 9000000008000180 <backtrace>
  panicked = 1; // freeze uart output from other CPUs
900000000800025c:	1c0002cc 	pcaddu12i	$r12,22(0x16)
9000000008000260:	02f6a18c 	addi.d	$r12,$r12,-600(0xda8)
9000000008000264:	0280040d 	addi.w	$r13,$r0,1(0x1)
9000000008000268:	2980018d 	st.w	$r13,$r12,0
    ;
900000000800026c:	50000000 	b	0 # 900000000800026c <panic+0x6c>

9000000008000270 <printf>:
void printf(char *fmt, ...) {
9000000008000270:	02fd4063 	addi.d	$r3,$r3,-176(0xf50)
9000000008000274:	29c1a061 	st.d	$r1,$r3,104(0x68)
9000000008000278:	29c18076 	st.d	$r22,$r3,96(0x60)
900000000800027c:	29c16077 	st.d	$r23,$r3,88(0x58)
9000000008000280:	29c14078 	st.d	$r24,$r3,80(0x50)
9000000008000284:	29c12079 	st.d	$r25,$r3,72(0x48)
9000000008000288:	29c1007a 	st.d	$r26,$r3,64(0x40)
900000000800028c:	29c0e07b 	st.d	$r27,$r3,56(0x38)
9000000008000290:	29c0c07c 	st.d	$r28,$r3,48(0x30)
9000000008000294:	29c0a07d 	st.d	$r29,$r3,40(0x28)
9000000008000298:	29c0807e 	st.d	$r30,$r3,32(0x20)
900000000800029c:	29c0607f 	st.d	$r31,$r3,24(0x18)
90000000080002a0:	02c1c076 	addi.d	$r22,$r3,112(0x70)
90000000080002a4:	0015009b 	move	$r27,$r4
90000000080002a8:	29c022c5 	st.d	$r5,$r22,8(0x8)
90000000080002ac:	29c042c6 	st.d	$r6,$r22,16(0x10)
90000000080002b0:	29c062c7 	st.d	$r7,$r22,24(0x18)
90000000080002b4:	29c082c8 	st.d	$r8,$r22,32(0x20)
90000000080002b8:	29c0a2c9 	st.d	$r9,$r22,40(0x28)
90000000080002bc:	29c0c2ca 	st.d	$r10,$r22,48(0x30)
90000000080002c0:	29c0e2cb 	st.d	$r11,$r22,56(0x38)
  locking = pr.locking;
90000000080002c4:	1c0002cc 	pcaddu12i	$r12,22(0x16)
90000000080002c8:	02f5118c 	addi.d	$r12,$r12,-700(0xd44)
90000000080002cc:	2880619f 	ld.w	$r31,$r12,24(0x18)
  if (locking)
90000000080002d0:	440037e0 	bnez	$r31,52(0x34) # 9000000008000304 <printf+0x94>
  if (fmt == 0) {
90000000080002d4:	40003f60 	beqz	$r27,60(0x3c) # 9000000008000310 <printf+0xa0>
  va_start(ap, fmt);
90000000080002d8:	02c022cc 	addi.d	$r12,$r22,8(0x8)
90000000080002dc:	29fe62cc 	st.d	$r12,$r22,-104(0xf98)
  for (i = 0; (c = fmt[i] & 0xff) != 0; i++) {
90000000080002e0:	2a000364 	ld.bu	$r4,$r27,0
90000000080002e4:	40016c80 	beqz	$r4,364(0x16c) # 9000000008000450 <printf+0x1e0>
90000000080002e8:	00150017 	move	$r23,$r0
    if (c != '%') {
90000000080002ec:	0280941a 	addi.w	$r26,$r0,37(0x25)
    switch (c) {
90000000080002f0:	0281c01c 	addi.w	$r28,$r0,112(0x70)
    consputc(digits[x >> (sizeof(uint64) * 8 - 4)]);
90000000080002f4:	1c00007d 	pcaddu12i	$r29,3(0x3)
90000000080002f8:	02f5b3bd 	addi.d	$r29,$r29,-660(0xd6c)
    switch (c) {
90000000080002fc:	0281cc1e 	addi.w	$r30,$r0,115(0x73)
9000000008000300:	50003800 	b	56(0x38) # 9000000008000338 <printf+0xc8>
    acquire(&pr.lock);
9000000008000304:	00150184 	move	$r4,$r12
9000000008000308:	54045400 	bl	1108(0x454) # 900000000800075c <acquire>
900000000800030c:	53ffcbff 	b	-56(0xfffffc8) # 90000000080002d4 <printf+0x64>
    consputc('A');
9000000008000310:	02810404 	addi.w	$r4,$r0,65(0x41)
9000000008000314:	540a2c00 	bl	2604(0xa2c) # 9000000008000d40 <consputc>
    panic("null fmt");
9000000008000318:	1c000064 	pcaddu12i	$r4,3(0x3)
900000000800031c:	02f4c084 	addi.d	$r4,$r4,-720(0xd30)
9000000008000320:	57fee3ff 	bl	-288(0xffffee0) # 9000000008000200 <panic>
      consputc(c);
9000000008000324:	540a1c00 	bl	2588(0xa1c) # 9000000008000d40 <consputc>
  for (i = 0; (c = fmt[i] & 0xff) != 0; i++) {
9000000008000328:	028006f7 	addi.w	$r23,$r23,1(0x1)
900000000800032c:	0010df6c 	add.d	$r12,$r27,$r23
9000000008000330:	2a000184 	ld.bu	$r4,$r12,0
9000000008000334:	40011c80 	beqz	$r4,284(0x11c) # 9000000008000450 <printf+0x1e0>
    if (c != '%') {
9000000008000338:	5fffec9a 	bne	$r4,$r26,-20(0x3ffec) # 9000000008000324 <printf+0xb4>
    c = fmt[++i] & 0xff;
900000000800033c:	028006f7 	addi.w	$r23,$r23,1(0x1)
9000000008000340:	0010df6c 	add.d	$r12,$r27,$r23
9000000008000344:	2a000198 	ld.bu	$r24,$r12,0
    if (c == 0)
9000000008000348:	40010b00 	beqz	$r24,264(0x108) # 9000000008000450 <printf+0x1e0>
    switch (c) {
900000000800034c:	5800631c 	beq	$r24,$r28,96(0x60) # 90000000080003ac <printf+0x13c>
9000000008000350:	64003398 	bge	$r28,$r24,48(0x30) # 9000000008000380 <printf+0x110>
9000000008000354:	58009f1e 	beq	$r24,$r30,156(0x9c) # 90000000080003f0 <printf+0x180>
9000000008000358:	0281e00c 	addi.w	$r12,$r0,120(0x78)
900000000800035c:	5c00e30c 	bne	$r24,$r12,224(0xe0) # 900000000800043c <printf+0x1cc>
      printint(va_arg(ap, int), 16, 1);
9000000008000360:	28fe62cc 	ld.d	$r12,$r22,-104(0xf98)
9000000008000364:	02c0218d 	addi.d	$r13,$r12,8(0x8)
9000000008000368:	29fe62cd 	st.d	$r13,$r22,-104(0xf98)
900000000800036c:	02800406 	addi.w	$r6,$r0,1(0x1)
9000000008000370:	02804005 	addi.w	$r5,$r0,16(0x10)
9000000008000374:	28800184 	ld.w	$r4,$r12,0
9000000008000378:	57fd27ff 	bl	-732(0xffffd24) # 900000000800009c <printint>
      break;
900000000800037c:	53ffafff 	b	-84(0xfffffac) # 9000000008000328 <printf+0xb8>
    switch (c) {
9000000008000380:	5800b31a 	beq	$r24,$r26,176(0xb0) # 9000000008000430 <printf+0x1c0>
9000000008000384:	0281900c 	addi.w	$r12,$r0,100(0x64)
9000000008000388:	5c00b70c 	bne	$r24,$r12,180(0xb4) # 900000000800043c <printf+0x1cc>
      printint(va_arg(ap, int), 10, 1);
900000000800038c:	28fe62cc 	ld.d	$r12,$r22,-104(0xf98)
9000000008000390:	02c0218d 	addi.d	$r13,$r12,8(0x8)
9000000008000394:	29fe62cd 	st.d	$r13,$r22,-104(0xf98)
9000000008000398:	02800406 	addi.w	$r6,$r0,1(0x1)
900000000800039c:	02802805 	addi.w	$r5,$r0,10(0xa)
90000000080003a0:	28800184 	ld.w	$r4,$r12,0
90000000080003a4:	57fcfbff 	bl	-776(0xffffcf8) # 900000000800009c <printint>
      break;
90000000080003a8:	53ff83ff 	b	-128(0xfffff80) # 9000000008000328 <printf+0xb8>
      printptr(va_arg(ap, uint64));
90000000080003ac:	28fe62cc 	ld.d	$r12,$r22,-104(0xf98)
90000000080003b0:	02c0218d 	addi.d	$r13,$r12,8(0x8)
90000000080003b4:	29fe62cd 	st.d	$r13,$r22,-104(0xf98)
90000000080003b8:	28c00199 	ld.d	$r25,$r12,0
  consputc('0');
90000000080003bc:	0280c004 	addi.w	$r4,$r0,48(0x30)
90000000080003c0:	54098000 	bl	2432(0x980) # 9000000008000d40 <consputc>
  consputc('x');
90000000080003c4:	0281e004 	addi.w	$r4,$r0,120(0x78)
90000000080003c8:	54097800 	bl	2424(0x978) # 9000000008000d40 <consputc>
90000000080003cc:	02804018 	addi.w	$r24,$r0,16(0x10)
    consputc(digits[x >> (sizeof(uint64) * 8 - 4)]);
90000000080003d0:	0045f32c 	srli.d	$r12,$r25,0x3c
90000000080003d4:	0010b3ac 	add.d	$r12,$r29,$r12
90000000080003d8:	28000184 	ld.b	$r4,$r12,0
90000000080003dc:	54096400 	bl	2404(0x964) # 9000000008000d40 <consputc>
  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
90000000080003e0:	00411339 	slli.d	$r25,$r25,0x4
90000000080003e4:	02bfff18 	addi.w	$r24,$r24,-1(0xfff)
90000000080003e8:	47ffeb1f 	bnez	$r24,-24(0x7fffe8) # 90000000080003d0 <printf+0x160>
90000000080003ec:	53ff3fff 	b	-196(0xfffff3c) # 9000000008000328 <printf+0xb8>
      if ((s = va_arg(ap, char *)) == 0)
90000000080003f0:	28fe62cc 	ld.d	$r12,$r22,-104(0xf98)
90000000080003f4:	02c0218d 	addi.d	$r13,$r12,8(0x8)
90000000080003f8:	29fe62cd 	st.d	$r13,$r22,-104(0xf98)
90000000080003fc:	28c00198 	ld.d	$r24,$r12,0
9000000008000400:	40002300 	beqz	$r24,32(0x20) # 9000000008000420 <printf+0x1b0>
      for (; *s; s++)
9000000008000404:	28000304 	ld.b	$r4,$r24,0
9000000008000408:	43ff209f 	beqz	$r4,-224(0x7fff20) # 9000000008000328 <printf+0xb8>
        consputc(*s);
900000000800040c:	54093400 	bl	2356(0x934) # 9000000008000d40 <consputc>
      for (; *s; s++)
9000000008000410:	02c00718 	addi.d	$r24,$r24,1(0x1)
9000000008000414:	28000304 	ld.b	$r4,$r24,0
9000000008000418:	47fff49f 	bnez	$r4,-12(0x7ffff4) # 900000000800040c <printf+0x19c>
900000000800041c:	53ff0fff 	b	-244(0xfffff0c) # 9000000008000328 <printf+0xb8>
        s = "(null)";
9000000008000420:	1c000078 	pcaddu12i	$r24,3(0x3)
9000000008000424:	02f08318 	addi.d	$r24,$r24,-992(0xc20)
      for (; *s; s++)
9000000008000428:	0280a004 	addi.w	$r4,$r0,40(0x28)
900000000800042c:	53ffe3ff 	b	-32(0xfffffe0) # 900000000800040c <printf+0x19c>
      consputc('%');
9000000008000430:	00150344 	move	$r4,$r26
9000000008000434:	54090c00 	bl	2316(0x90c) # 9000000008000d40 <consputc>
      break;
9000000008000438:	53fef3ff 	b	-272(0xffffef0) # 9000000008000328 <printf+0xb8>
      consputc('%');
900000000800043c:	00150344 	move	$r4,$r26
9000000008000440:	54090000 	bl	2304(0x900) # 9000000008000d40 <consputc>
      consputc(c);
9000000008000444:	00150304 	move	$r4,$r24
9000000008000448:	5408f800 	bl	2296(0x8f8) # 9000000008000d40 <consputc>
      break;
900000000800044c:	53fedfff 	b	-292(0xffffedc) # 9000000008000328 <printf+0xb8>
  if (locking)
9000000008000450:	44003be0 	bnez	$r31,56(0x38) # 9000000008000488 <printf+0x218>
}
9000000008000454:	28c1a061 	ld.d	$r1,$r3,104(0x68)
9000000008000458:	28c18076 	ld.d	$r22,$r3,96(0x60)
900000000800045c:	28c16077 	ld.d	$r23,$r3,88(0x58)
9000000008000460:	28c14078 	ld.d	$r24,$r3,80(0x50)
9000000008000464:	28c12079 	ld.d	$r25,$r3,72(0x48)
9000000008000468:	28c1007a 	ld.d	$r26,$r3,64(0x40)
900000000800046c:	28c0e07b 	ld.d	$r27,$r3,56(0x38)
9000000008000470:	28c0c07c 	ld.d	$r28,$r3,48(0x30)
9000000008000474:	28c0a07d 	ld.d	$r29,$r3,40(0x28)
9000000008000478:	28c0807e 	ld.d	$r30,$r3,32(0x20)
900000000800047c:	28c0607f 	ld.d	$r31,$r3,24(0x18)
9000000008000480:	02c2c063 	addi.d	$r3,$r3,176(0xb0)
9000000008000484:	4c000020 	jirl	$r0,$r1,0
    release(&pr.lock);
9000000008000488:	1c0002c4 	pcaddu12i	$r4,22(0x16)
900000000800048c:	02ee0084 	addi.d	$r4,$r4,-1152(0xb80)
9000000008000490:	54032c00 	bl	812(0x32c) # 90000000080007bc <release>
}
9000000008000494:	53ffc3ff 	b	-64(0xfffffc0) # 9000000008000454 <printf+0x1e4>

9000000008000498 <printfinit>:

void printfinit(void) {
9000000008000498:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
900000000800049c:	29c02061 	st.d	$r1,$r3,8(0x8)
90000000080004a0:	29c00076 	st.d	$r22,$r3,0
90000000080004a4:	02c04076 	addi.d	$r22,$r3,16(0x10)
  initlock(&pr.lock, "pr");
90000000080004a8:	1c000065 	pcaddu12i	$r5,3(0x3)
90000000080004ac:	02eec0a5 	addi.d	$r5,$r5,-1104(0xbb0)
90000000080004b0:	1c0002c4 	pcaddu12i	$r4,22(0x16)
90000000080004b4:	02ed6084 	addi.d	$r4,$r4,-1192(0xb58)
90000000080004b8:	54023800 	bl	568(0x238) # 90000000080006f0 <initlock>
  pr.locking = 1; // changed, used to be 1
90000000080004bc:	1c0002cc 	pcaddu12i	$r12,22(0x16)
90000000080004c0:	02ed318c 	addi.d	$r12,$r12,-1204(0xb4c)
90000000080004c4:	0280040d 	addi.w	$r13,$r0,1(0x1)
90000000080004c8:	2980618d 	st.w	$r13,$r12,24(0x18)
}
90000000080004cc:	28c02061 	ld.d	$r1,$r3,8(0x8)
90000000080004d0:	28c00076 	ld.d	$r22,$r3,0
90000000080004d4:	02c04063 	addi.d	$r3,$r3,16(0x10)
90000000080004d8:	4c000020 	jirl	$r0,$r1,0

90000000080004dc <uartinit>:

extern volatile int panicked; // from printf.c

void
uartinit(void)
{
90000000080004dc:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
90000000080004e0:	29c02061 	st.d	$r1,$r3,8(0x8)
90000000080004e4:	29c00076 	st.d	$r22,$r3,0
90000000080004e8:	02c04076 	addi.d	$r22,$r3,16(0x10)
  // disable interrupts.
  WriteReg(IER, 0x00);
90000000080004ec:	143fc40c 	lu12i.w	$r12,130592(0x1fe20)
90000000080004f0:	0380058d 	ori	$r13,$r12,0x1
90000000080004f4:	032401ad 	lu52i.d	$r13,$r13,-1792(0x900)
90000000080004f8:	290001a0 	st.b	$r0,$r13,0

  // special mode to set baud rate.
  WriteReg(LCR, LCR_BAUD_LATCH);
90000000080004fc:	03800d8e 	ori	$r14,$r12,0x3
9000000008000500:	032401ce 	lu52i.d	$r14,$r14,-1792(0x900)
9000000008000504:	02be000f 	addi.w	$r15,$r0,-128(0xf80)
9000000008000508:	290001cf 	st.b	$r15,$r14,0

  // LSB for baud rate of 38.4K.
  WriteReg(0, 0x03);
900000000800050c:	03240190 	lu52i.d	$r16,$r12,-1792(0x900)
9000000008000510:	02800c0f 	addi.w	$r15,$r0,3(0x3)
9000000008000514:	2900020f 	st.b	$r15,$r16,0

  // MSB for baud rate of 38.4K.
  WriteReg(1, 0x00);
9000000008000518:	290001a0 	st.b	$r0,$r13,0

  // leave set-baud mode,
  // and set word length to 8 bits, no parity.
  WriteReg(LCR, LCR_EIGHT_BITS);
900000000800051c:	290001cf 	st.b	$r15,$r14,0

  // reset and enable FIFOs.
  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);
9000000008000520:	0380098c 	ori	$r12,$r12,0x2
9000000008000524:	0324018c 	lu52i.d	$r12,$r12,-1792(0x900)
9000000008000528:	02801c0e 	addi.w	$r14,$r0,7(0x7)
900000000800052c:	2900018e 	st.b	$r14,$r12,0

  // enable transmit and receive interrupts.
  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);
9000000008000530:	290001af 	st.b	$r15,$r13,0

  initlock(&uart_tx_lock, "uart");
9000000008000534:	1c000065 	pcaddu12i	$r5,3(0x3)
9000000008000538:	02ed10a5 	addi.d	$r5,$r5,-1212(0xb44)
900000000800053c:	1c0002c4 	pcaddu12i	$r4,22(0x16)
9000000008000540:	02ec7084 	addi.d	$r4,$r4,-1252(0xb1c)
9000000008000544:	5401ac00 	bl	428(0x1ac) # 90000000080006f0 <initlock>
}
9000000008000548:	28c02061 	ld.d	$r1,$r3,8(0x8)
900000000800054c:	28c00076 	ld.d	$r22,$r3,0
9000000008000550:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000554:	4c000020 	jirl	$r0,$r1,0

9000000008000558 <uartputc_sync>:
// use interrupts, for use by kernel printf() and
// to echo characters. it spins waiting for the uart's
// output register to be empty.
void
uartputc_sync(int c)
{
9000000008000558:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
900000000800055c:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008000560:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008000564:	29c02077 	st.d	$r23,$r3,8(0x8)
9000000008000568:	02c08076 	addi.d	$r22,$r3,32(0x20)
900000000800056c:	00150097 	move	$r23,$r4
  push_off();
9000000008000570:	5400a000 	bl	160(0xa0) # 9000000008000610 <push_off>

  if(panicked){
9000000008000574:	1c0000ac 	pcaddu12i	$r12,5(0x5)
9000000008000578:	28ea718c 	ld.d	$r12,$r12,-1380(0xa9c)
900000000800057c:	2880018c 	ld.w	$r12,$r12,0
    for(;;)
      ;
  }

  // wait for Transmit Holding Empty to be set in LSR.
  while((ReadReg(LSR) & LSR_TX_IDLE) == 0)
9000000008000580:	143fc40d 	lu12i.w	$r13,130592(0x1fe20)
  if(panicked){
9000000008000584:	40000980 	beqz	$r12,8(0x8) # 900000000800058c <uartputc_sync+0x34>
      ;
9000000008000588:	50000000 	b	0 # 9000000008000588 <uartputc_sync+0x30>
  while((ReadReg(LSR) & LSR_TX_IDLE) == 0)
900000000800058c:	038015ac 	ori	$r12,$r13,0x5
9000000008000590:	0324018c 	lu52i.d	$r12,$r12,-1792(0x900)
9000000008000594:	2a00018c 	ld.bu	$r12,$r12,0
9000000008000598:	00c5158c 	bstrpick.d	$r12,$r12,0x5,0x5
900000000800059c:	43fff19f 	beqz	$r12,-16(0x7ffff0) # 900000000800058c <uartputc_sync+0x34>
    ;
  WriteReg(THR, c);
90000000080005a0:	006782ed 	bstrpick.w	$r13,$r23,0x7,0x0
90000000080005a4:	143fc40c 	lu12i.w	$r12,130592(0x1fe20)
90000000080005a8:	0324018c 	lu52i.d	$r12,$r12,-1792(0x900)
90000000080005ac:	2900018d 	st.b	$r13,$r12,0

  pop_off();
90000000080005b0:	5400d000 	bl	208(0xd0) # 9000000008000680 <pop_off>
}
90000000080005b4:	28c06061 	ld.d	$r1,$r3,24(0x18)
90000000080005b8:	28c04076 	ld.d	$r22,$r3,16(0x10)
90000000080005bc:	28c02077 	ld.d	$r23,$r3,8(0x8)
90000000080005c0:	02c08063 	addi.d	$r3,$r3,32(0x20)
90000000080005c4:	4c000020 	jirl	$r0,$r1,0

90000000080005c8 <uartgetc>:

// read one input character from the UART.
// return -1 if none is waiting.
int
uartgetc(void)
{
90000000080005c8:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
90000000080005cc:	29c02076 	st.d	$r22,$r3,8(0x8)
90000000080005d0:	02c04076 	addi.d	$r22,$r3,16(0x10)
  if(ReadReg(LSR) & 0x01){
90000000080005d4:	143fc40c 	lu12i.w	$r12,130592(0x1fe20)
90000000080005d8:	0380158c 	ori	$r12,$r12,0x5
90000000080005dc:	0324018c 	lu52i.d	$r12,$r12,-1792(0x900)
90000000080005e0:	2a00018c 	ld.bu	$r12,$r12,0
90000000080005e4:	0340058c 	andi	$r12,$r12,0x1
90000000080005e8:	40002180 	beqz	$r12,32(0x20) # 9000000008000608 <uartgetc+0x40>
    // input data is ready.
    return ReadReg(RHR);
90000000080005ec:	143fc40c 	lu12i.w	$r12,130592(0x1fe20)
90000000080005f0:	0324018c 	lu52i.d	$r12,$r12,-1792(0x900)
90000000080005f4:	2a000184 	ld.bu	$r4,$r12,0
90000000080005f8:	00678084 	bstrpick.w	$r4,$r4,0x7,0x0
  } else {
    return -1;
  }
}
90000000080005fc:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000600:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000604:	4c000020 	jirl	$r0,$r1,0
    return -1;
9000000008000608:	02bffc04 	addi.w	$r4,$r0,-1(0xfff)
900000000800060c:	53fff3ff 	b	-16(0xffffff0) # 90000000080005fc <uartgetc+0x34>

9000000008000610 <push_off>:

// push_off/pop_off are like intr_off()/intr_on() except that they are matched:
// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts
// are initially off, then push_off, pop_off leaves them off.

void push_off(void) {
9000000008000610:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008000614:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008000618:	29c04076 	st.d	$r22,$r3,16(0x10)
900000000800061c:	29c02077 	st.d	$r23,$r3,8(0x8)
9000000008000620:	02c08076 	addi.d	$r22,$r3,32(0x20)

static inline uint32
r_csr_crmd()
{
  uint32 x;
  asm volatile("csrrd %0, 0x0" : "=r" (x) );
9000000008000624:	0400000c 	csrrd	$r12,0x0
9000000008000628:	00150197 	move	$r23,$r12
900000000800062c:	0400000c 	csrrd	$r12,0x0

// disable device interrupts
static inline void
intr_off()
{
  w_csr_crmd(r_csr_crmd() & ~CSR_CRMD_IE);
9000000008000630:	02bfec0d 	addi.w	$r13,$r0,-5(0xffb)
9000000008000634:	0014b58c 	and	$r12,$r12,$r13
  asm volatile("csrwr %0, 0x0" : : "r" (x));
9000000008000638:	0400002c 	csrwr	$r12,0x0
  int old = intr_get();

  intr_off();
  // printf("\e[32mpush_off()\e[0m: cpuid(): %d\n", cpuid());
  if (mycpu()->noff == 0)
900000000800063c:	5406d000 	bl	1744(0x6d0) # 9000000008000d0c <mycpu>
9000000008000640:	2881a08c 	ld.w	$r12,$r4,104(0x68)
9000000008000644:	40002980 	beqz	$r12,40(0x28) # 900000000800066c <push_off+0x5c>
    mycpu()->intena = old;
  // printstring("push_off noff++ noff:\n");
  // printint(mycpu()->noff, 10, 1);
  // consputc('\n');
  mycpu()->noff += 1;
9000000008000648:	5406c400 	bl	1732(0x6c4) # 9000000008000d0c <mycpu>
900000000800064c:	2881a08c 	ld.w	$r12,$r4,104(0x68)
9000000008000650:	0280058c 	addi.w	$r12,$r12,1(0x1)
9000000008000654:	2981a08c 	st.w	$r12,$r4,104(0x68)
}
9000000008000658:	28c06061 	ld.d	$r1,$r3,24(0x18)
900000000800065c:	28c04076 	ld.d	$r22,$r3,16(0x10)
9000000008000660:	28c02077 	ld.d	$r23,$r3,8(0x8)
9000000008000664:	02c08063 	addi.d	$r3,$r3,32(0x20)
9000000008000668:	4c000020 	jirl	$r0,$r1,0
    mycpu()->intena = old;
900000000800066c:	5406a000 	bl	1696(0x6a0) # 9000000008000d0c <mycpu>
  return (x & CSR_CRMD_IE) != 0;
9000000008000670:	00488aec 	srai.w	$r12,$r23,0x2
9000000008000674:	0340058c 	andi	$r12,$r12,0x1
9000000008000678:	2981b08c 	st.w	$r12,$r4,108(0x6c)
900000000800067c:	53ffcfff 	b	-52(0xfffffcc) # 9000000008000648 <push_off+0x38>

9000000008000680 <pop_off>:

void pop_off(void) {
9000000008000680:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000684:	29c02061 	st.d	$r1,$r3,8(0x8)
9000000008000688:	29c00076 	st.d	$r22,$r3,0
900000000800068c:	02c04076 	addi.d	$r22,$r3,16(0x10)
  struct cpu *c = mycpu();
9000000008000690:	54067c00 	bl	1660(0x67c) # 9000000008000d0c <mycpu>
  asm volatile("csrrd %0, 0x0" : "=r" (x) );
9000000008000694:	0400000c 	csrrd	$r12,0x0

  // printf("\e[31mpop_off()\e[0m: cpuid(): %d\n", cpuid());
  if (intr_get())
9000000008000698:	00c2098c 	bstrpick.d	$r12,$r12,0x2,0x2
900000000800069c:	44003d80 	bnez	$r12,60(0x3c) # 90000000080006d8 <pop_off+0x58>
    panic("pop_off - interruptible");
  if (c->noff < 1) {
90000000080006a0:	2881a08c 	ld.w	$r12,$r4,104(0x68)
90000000080006a4:	6400400c 	bge	$r0,$r12,64(0x40) # 90000000080006e4 <pop_off+0x64>
  // printf("c: %x\n", c);
  // printstring("pop_off noff--\n");
  // printstring("pop_off noff-- noff:\n");
  // printint(mycpu()->noff, 10, 1);
  // consputc('\n');
  c->noff -= 1;
90000000080006a8:	02bffd8c 	addi.w	$r12,$r12,-1(0xfff)
90000000080006ac:	2981a08c 	st.w	$r12,$r4,104(0x68)
  if (c->noff == 0 && c->intena)
90000000080006b0:	44001980 	bnez	$r12,24(0x18) # 90000000080006c8 <pop_off+0x48>
90000000080006b4:	2881b08c 	ld.w	$r12,$r4,108(0x6c)
90000000080006b8:	40001180 	beqz	$r12,16(0x10) # 90000000080006c8 <pop_off+0x48>
90000000080006bc:	0400000c 	csrrd	$r12,0x0
  w_csr_crmd(r_csr_crmd() | CSR_CRMD_IE);
90000000080006c0:	0380118c 	ori	$r12,$r12,0x4
  asm volatile("csrwr %0, 0x0" : : "r" (x));
90000000080006c4:	0400002c 	csrwr	$r12,0x0
    intr_on();
}
90000000080006c8:	28c02061 	ld.d	$r1,$r3,8(0x8)
90000000080006cc:	28c00076 	ld.d	$r22,$r3,0
90000000080006d0:	02c04063 	addi.d	$r3,$r3,16(0x10)
90000000080006d4:	4c000020 	jirl	$r0,$r1,0
    panic("pop_off - interruptible");
90000000080006d8:	1c000064 	pcaddu12i	$r4,3(0x3)
90000000080006dc:	02e6a084 	addi.d	$r4,$r4,-1624(0x9a8)
90000000080006e0:	57fb23ff 	bl	-1248(0xffffb20) # 9000000008000200 <panic>
    panic("pop_off");
90000000080006e4:	1c000064 	pcaddu12i	$r4,3(0x3)
90000000080006e8:	02e6d084 	addi.d	$r4,$r4,-1612(0x9b4)
90000000080006ec:	57fb17ff 	bl	-1260(0xffffb14) # 9000000008000200 <panic>

90000000080006f0 <initlock>:
#include "include/printf.h"
// #include "include/proc.h"
// #include "include/loongarch.h"
// #include "include/types.h"

void initlock(struct spinlock *lk, char *name) {
90000000080006f0:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
90000000080006f4:	29c02076 	st.d	$r22,$r3,8(0x8)
90000000080006f8:	02c04076 	addi.d	$r22,$r3,16(0x10)
  lk->name = name;
90000000080006fc:	29c02085 	st.d	$r5,$r4,8(0x8)
  lk->locked = 0;
9000000008000700:	29800080 	st.w	$r0,$r4,0
  lk->cpu = 0;
9000000008000704:	29c04080 	st.d	$r0,$r4,16(0x10)
}
9000000008000708:	28c02076 	ld.d	$r22,$r3,8(0x8)
900000000800070c:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000710:	4c000020 	jirl	$r0,$r1,0

9000000008000714 <holding>:

// Check whether this cpu is holding the lock.
// Interrupts must be off.
int holding(struct spinlock *lk) {
  int r;
  r = (lk->locked && lk->cpu == mycpu());
9000000008000714:	2880008c 	ld.w	$r12,$r4,0
9000000008000718:	44000d80 	bnez	$r12,12(0xc) # 9000000008000724 <holding+0x10>
900000000800071c:	00150004 	move	$r4,$r0
  return r;
}
9000000008000720:	4c000020 	jirl	$r0,$r1,0
int holding(struct spinlock *lk) {
9000000008000724:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008000728:	29c06061 	st.d	$r1,$r3,24(0x18)
900000000800072c:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008000730:	29c02077 	st.d	$r23,$r3,8(0x8)
9000000008000734:	02c08076 	addi.d	$r22,$r3,32(0x20)
  r = (lk->locked && lk->cpu == mycpu());
9000000008000738:	28c04097 	ld.d	$r23,$r4,16(0x10)
900000000800073c:	5405d000 	bl	1488(0x5d0) # 9000000008000d0c <mycpu>
9000000008000740:	001592e4 	xor	$r4,$r23,$r4
9000000008000744:	02400484 	sltui	$r4,$r4,1(0x1)
}
9000000008000748:	28c06061 	ld.d	$r1,$r3,24(0x18)
900000000800074c:	28c04076 	ld.d	$r22,$r3,16(0x10)
9000000008000750:	28c02077 	ld.d	$r23,$r3,8(0x8)
9000000008000754:	02c08063 	addi.d	$r3,$r3,32(0x20)
9000000008000758:	4c000020 	jirl	$r0,$r1,0

900000000800075c <acquire>:
void acquire(struct spinlock *lk) {
900000000800075c:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008000760:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008000764:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008000768:	29c02077 	st.d	$r23,$r3,8(0x8)
900000000800076c:	02c08076 	addi.d	$r22,$r3,32(0x20)
9000000008000770:	00150097 	move	$r23,$r4
  push_off(); // disable interrupts to avoid deadlock.
9000000008000774:	57fe9fff 	bl	-356(0xffffe9c) # 9000000008000610 <push_off>
  if (holding(lk))
9000000008000778:	001502e4 	move	$r4,$r23
900000000800077c:	57ff9bff 	bl	-104(0xfffff98) # 9000000008000714 <holding>
  while (__sync_lock_test_and_set(&lk->locked, 1) != 0)
9000000008000780:	0280040d 	addi.w	$r13,$r0,1(0x1)
  if (holding(lk))
9000000008000784:	44002c80 	bnez	$r4,44(0x2c) # 90000000080007b0 <acquire+0x54>
  while (__sync_lock_test_and_set(&lk->locked, 1) != 0)
9000000008000788:	386936ec 	amswap_db.w	$r12,$r13,$r23
900000000800078c:	47fffd9f 	bnez	$r12,-4(0x7ffffc) # 9000000008000788 <acquire+0x2c>
  __sync_synchronize();
9000000008000790:	38720000 	dbar	0x0
  lk->cpu = mycpu();
9000000008000794:	54057800 	bl	1400(0x578) # 9000000008000d0c <mycpu>
9000000008000798:	29c042e4 	st.d	$r4,$r23,16(0x10)
}
900000000800079c:	28c06061 	ld.d	$r1,$r3,24(0x18)
90000000080007a0:	28c04076 	ld.d	$r22,$r3,16(0x10)
90000000080007a4:	28c02077 	ld.d	$r23,$r3,8(0x8)
90000000080007a8:	02c08063 	addi.d	$r3,$r3,32(0x20)
90000000080007ac:	4c000020 	jirl	$r0,$r1,0
    panic("acquire");
90000000080007b0:	1c000064 	pcaddu12i	$r4,3(0x3)
90000000080007b4:	02e3c084 	addi.d	$r4,$r4,-1808(0x8f0)
90000000080007b8:	57fa4bff 	bl	-1464(0xffffa48) # 9000000008000200 <panic>

90000000080007bc <release>:
void release(struct spinlock *lk) {
90000000080007bc:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
90000000080007c0:	29c06061 	st.d	$r1,$r3,24(0x18)
90000000080007c4:	29c04076 	st.d	$r22,$r3,16(0x10)
90000000080007c8:	29c02077 	st.d	$r23,$r3,8(0x8)
90000000080007cc:	02c08076 	addi.d	$r22,$r3,32(0x20)
90000000080007d0:	00150097 	move	$r23,$r4
  if (!holding(lk))
90000000080007d4:	57ff43ff 	bl	-192(0xfffff40) # 9000000008000714 <holding>
90000000080007d8:	40002c80 	beqz	$r4,44(0x2c) # 9000000008000804 <release+0x48>
  lk->cpu = 0;
90000000080007dc:	29c042e0 	st.d	$r0,$r23,16(0x10)
  __sync_synchronize();
90000000080007e0:	38720000 	dbar	0x0
  __sync_lock_release(&lk->locked);
90000000080007e4:	38720001 	dbar	0x1
90000000080007e8:	298002e0 	st.w	$r0,$r23,0
  pop_off();
90000000080007ec:	57fe97ff 	bl	-364(0xffffe94) # 9000000008000680 <pop_off>
}
90000000080007f0:	28c06061 	ld.d	$r1,$r3,24(0x18)
90000000080007f4:	28c04076 	ld.d	$r22,$r3,16(0x10)
90000000080007f8:	28c02077 	ld.d	$r23,$r3,8(0x8)
90000000080007fc:	02c08063 	addi.d	$r3,$r3,32(0x20)
9000000008000800:	4c000020 	jirl	$r0,$r1,0
    panic("release");
9000000008000804:	1c000064 	pcaddu12i	$r4,3(0x3)
9000000008000808:	02e29084 	addi.d	$r4,$r4,-1884(0x8a4)
900000000800080c:	57f9f7ff 	bl	-1548(0xffff9f4) # 9000000008000200 <panic>

9000000008000810 <memset>:
#include "include/types.h"

void *memset(void *dst, int c, uint n) {
9000000008000810:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000814:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000818:	02c04076 	addi.d	$r22,$r3,16(0x10)
  char *cdst = (char *)dst;
  int i;
  for (i = 0; i < n; i++) {
900000000800081c:	400024c0 	beqz	$r6,36(0x24) # 9000000008000840 <memset+0x30>
9000000008000820:	0015008c 	move	$r12,$r4
9000000008000824:	02bffccd 	addi.w	$r13,$r6,-1(0xfff)
9000000008000828:	00df01ad 	bstrpick.d	$r13,$r13,0x1f,0x0
900000000800082c:	02c005ad 	addi.d	$r13,$r13,1(0x1)
9000000008000830:	001091ad 	add.d	$r13,$r13,$r4
    cdst[i] = c;
9000000008000834:	29000185 	st.b	$r5,$r12,0
9000000008000838:	02c0058c 	addi.d	$r12,$r12,1(0x1)
  for (i = 0; i < n; i++) {
900000000800083c:	5ffff98d 	bne	$r12,$r13,-8(0x3fff8) # 9000000008000834 <memset+0x24>
  }
  return dst;
}
9000000008000840:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000844:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000848:	4c000020 	jirl	$r0,$r1,0

900000000800084c <memcmp>:

int memcmp(const void *v1, const void *v2, uint n) {
900000000800084c:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000850:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000854:	02c04076 	addi.d	$r22,$r3,16(0x10)
  const uchar *s1, *s2;

  s1 = v1;
  s2 = v2;
  while (n-- > 0) {
9000000008000858:	400058c0 	beqz	$r6,88(0x58) # 90000000080008b0 <memcmp+0x64>
900000000800085c:	02bffccf 	addi.w	$r15,$r6,-1(0xfff)
    if (*s1 != *s2)
9000000008000860:	2a00008c 	ld.bu	$r12,$r4,0
9000000008000864:	2a0000ad 	ld.bu	$r13,$r5,0
9000000008000868:	0015018e 	move	$r14,$r12
900000000800086c:	00df01ef 	bstrpick.d	$r15,$r15,0x1f,0x0
9000000008000870:	02c005ef 	addi.d	$r15,$r15,1(0x1)
9000000008000874:	0010bc8f 	add.d	$r15,$r4,$r15
9000000008000878:	5c0021cd 	bne	$r14,$r13,32(0x20) # 9000000008000898 <memcmp+0x4c>
      return *s1 - *s2;
    s1++, s2++;
900000000800087c:	02c00484 	addi.d	$r4,$r4,1(0x1)
9000000008000880:	02c004a5 	addi.d	$r5,$r5,1(0x1)
  while (n-- > 0) {
9000000008000884:	5800248f 	beq	$r4,$r15,36(0x24) # 90000000080008a8 <memcmp+0x5c>
    if (*s1 != *s2)
9000000008000888:	2a00008c 	ld.bu	$r12,$r4,0
900000000800088c:	2a0000ad 	ld.bu	$r13,$r5,0
9000000008000890:	0015018e 	move	$r14,$r12
9000000008000894:	5bffe9cd 	beq	$r14,$r13,-24(0x3ffe8) # 900000000800087c <memcmp+0x30>
      return *s1 - *s2;
9000000008000898:	00113584 	sub.w	$r4,$r12,$r13
  }

  return 0;
}
900000000800089c:	28c02076 	ld.d	$r22,$r3,8(0x8)
90000000080008a0:	02c04063 	addi.d	$r3,$r3,16(0x10)
90000000080008a4:	4c000020 	jirl	$r0,$r1,0
  return 0;
90000000080008a8:	00150004 	move	$r4,$r0
90000000080008ac:	53fff3ff 	b	-16(0xffffff0) # 900000000800089c <memcmp+0x50>
90000000080008b0:	00150004 	move	$r4,$r0
90000000080008b4:	53ffebff 	b	-24(0xfffffe8) # 900000000800089c <memcmp+0x50>

90000000080008b8 <memmove>:

void *memmove(void *dst, const void *src, uint n) {
90000000080008b8:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
90000000080008bc:	29c02076 	st.d	$r22,$r3,8(0x8)
90000000080008c0:	02c04076 	addi.d	$r22,$r3,16(0x10)
  const char *s;
  char *d;

  s = src;
  d = dst;
  if (s < d && s + n > d) {
90000000080008c4:	68003ca4 	bltu	$r5,$r4,60(0x3c) # 9000000008000900 <memmove+0x48>
    s += n;
    d += n;
    while (n-- > 0)
      *--d = *--s;
  } else
    while (n-- > 0)
90000000080008c8:	02bffcce 	addi.w	$r14,$r6,-1(0xfff)
90000000080008cc:	00df01ce 	bstrpick.d	$r14,$r14,0x1f,0x0
90000000080008d0:	02c005ce 	addi.d	$r14,$r14,1(0x1)
90000000080008d4:	0010b8ae 	add.d	$r14,$r5,$r14
90000000080008d8:	0015008c 	move	$r12,$r4
90000000080008dc:	400018c0 	beqz	$r6,24(0x18) # 90000000080008f4 <memmove+0x3c>
      *d++ = *s++;
90000000080008e0:	02c004a5 	addi.d	$r5,$r5,1(0x1)
90000000080008e4:	02c0058c 	addi.d	$r12,$r12,1(0x1)
90000000080008e8:	283ffcad 	ld.b	$r13,$r5,-1(0xfff)
90000000080008ec:	293ffd8d 	st.b	$r13,$r12,-1(0xfff)
    while (n-- > 0)
90000000080008f0:	5ffff0ae 	bne	$r5,$r14,-16(0x3fff0) # 90000000080008e0 <memmove+0x28>

  return dst;
}
90000000080008f4:	28c02076 	ld.d	$r22,$r3,8(0x8)
90000000080008f8:	02c04063 	addi.d	$r3,$r3,16(0x10)
90000000080008fc:	4c000020 	jirl	$r0,$r1,0
  if (s < d && s + n > d) {
9000000008000900:	00df00cd 	bstrpick.d	$r13,$r6,0x1f,0x0
9000000008000904:	0010b4ac 	add.d	$r12,$r5,$r13
9000000008000908:	6fffc08c 	bgeu	$r4,$r12,-64(0x3ffc0) # 90000000080008c8 <memmove+0x10>
    d += n;
900000000800090c:	0010b48d 	add.d	$r13,$r4,$r13
    while (n-- > 0)
9000000008000910:	02bffcce 	addi.w	$r14,$r6,-1(0xfff)
9000000008000914:	43ffe0df 	beqz	$r6,-32(0x7fffe0) # 90000000080008f4 <memmove+0x3c>
9000000008000918:	00df01cf 	bstrpick.d	$r15,$r14,0x1f,0x0
900000000800091c:	00143c0f 	nor	$r15,$r0,$r15
9000000008000920:	0010bd8f 	add.d	$r15,$r12,$r15
      *--d = *--s;
9000000008000924:	02fffd8c 	addi.d	$r12,$r12,-1(0xfff)
9000000008000928:	02fffdad 	addi.d	$r13,$r13,-1(0xfff)
900000000800092c:	2800018e 	ld.b	$r14,$r12,0
9000000008000930:	290001ae 	st.b	$r14,$r13,0
    while (n-- > 0)
9000000008000934:	5ffff1ec 	bne	$r15,$r12,-16(0x3fff0) # 9000000008000924 <memmove+0x6c>
9000000008000938:	53ffbfff 	b	-68(0xfffffbc) # 90000000080008f4 <memmove+0x3c>

900000000800093c <memcpy>:

// memcpy exists to placate GCC.  Use memmove.
void *memcpy(void *dst, const void *src, uint n) {
900000000800093c:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000940:	29c02061 	st.d	$r1,$r3,8(0x8)
9000000008000944:	29c00076 	st.d	$r22,$r3,0
9000000008000948:	02c04076 	addi.d	$r22,$r3,16(0x10)
  return memmove(dst, src, n);
900000000800094c:	57ff6fff 	bl	-148(0xfffff6c) # 90000000080008b8 <memmove>
}
9000000008000950:	28c02061 	ld.d	$r1,$r3,8(0x8)
9000000008000954:	28c00076 	ld.d	$r22,$r3,0
9000000008000958:	02c04063 	addi.d	$r3,$r3,16(0x10)
900000000800095c:	4c000020 	jirl	$r0,$r1,0

9000000008000960 <strncmp>:

int strncmp(const char *p, const char *q, uint n) {
9000000008000960:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000964:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000968:	02c04076 	addi.d	$r22,$r3,16(0x10)
  while (n > 0 && *p && *p == *q)
900000000800096c:	400058c0 	beqz	$r6,88(0x58) # 90000000080009c4 <strncmp+0x64>
9000000008000970:	2800008c 	ld.b	$r12,$r4,0
9000000008000974:	40003980 	beqz	$r12,56(0x38) # 90000000080009ac <strncmp+0x4c>
9000000008000978:	280000ad 	ld.b	$r13,$r5,0
900000000800097c:	5c0031ac 	bne	$r13,$r12,48(0x30) # 90000000080009ac <strncmp+0x4c>
9000000008000980:	02bffccd 	addi.w	$r13,$r6,-1(0xfff)
9000000008000984:	00df01ad 	bstrpick.d	$r13,$r13,0x1f,0x0
9000000008000988:	02c005ad 	addi.d	$r13,$r13,1(0x1)
900000000800098c:	0010b48d 	add.d	$r13,$r4,$r13
    n--, p++, q++;
9000000008000990:	02c00484 	addi.d	$r4,$r4,1(0x1)
9000000008000994:	02c004a5 	addi.d	$r5,$r5,1(0x1)
  while (n > 0 && *p && *p == *q)
9000000008000998:	5800348d 	beq	$r4,$r13,52(0x34) # 90000000080009cc <strncmp+0x6c>
900000000800099c:	2800008c 	ld.b	$r12,$r4,0
90000000080009a0:	40000d80 	beqz	$r12,12(0xc) # 90000000080009ac <strncmp+0x4c>
90000000080009a4:	280000ae 	ld.b	$r14,$r5,0
90000000080009a8:	5bffe9cc 	beq	$r14,$r12,-24(0x3ffe8) # 9000000008000990 <strncmp+0x30>
  if (n == 0)
    return 0;
  return (uchar)*p - (uchar)*q;
90000000080009ac:	2a000084 	ld.bu	$r4,$r4,0
90000000080009b0:	2a0000ac 	ld.bu	$r12,$r5,0
90000000080009b4:	00113084 	sub.w	$r4,$r4,$r12
}
90000000080009b8:	28c02076 	ld.d	$r22,$r3,8(0x8)
90000000080009bc:	02c04063 	addi.d	$r3,$r3,16(0x10)
90000000080009c0:	4c000020 	jirl	$r0,$r1,0
    return 0;
90000000080009c4:	00150004 	move	$r4,$r0
90000000080009c8:	53fff3ff 	b	-16(0xffffff0) # 90000000080009b8 <strncmp+0x58>
90000000080009cc:	00150004 	move	$r4,$r0
90000000080009d0:	53ffebff 	b	-24(0xfffffe8) # 90000000080009b8 <strncmp+0x58>

90000000080009d4 <strncpy>:

char *strncpy(char *s, const char *t, int n) {
90000000080009d4:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
90000000080009d8:	29c02076 	st.d	$r22,$r3,8(0x8)
90000000080009dc:	02c04076 	addi.d	$r22,$r3,16(0x10)
  char *os;

  os = s;
  while (n-- > 0 && (*s++ = *t++) != 0)
90000000080009e0:	0015008c 	move	$r12,$r4
90000000080009e4:	50000800 	b	8(0x8) # 90000000080009ec <strncpy+0x18>
90000000080009e8:	001501e6 	move	$r6,$r15
90000000080009ec:	02bffccf 	addi.w	$r15,$r6,-1(0xfff)
90000000080009f0:	64001806 	bge	$r0,$r6,24(0x18) # 9000000008000a08 <strncpy+0x34>
90000000080009f4:	02c0058c 	addi.d	$r12,$r12,1(0x1)
90000000080009f8:	280000ad 	ld.b	$r13,$r5,0
90000000080009fc:	293ffd8d 	st.b	$r13,$r12,-1(0xfff)
9000000008000a00:	02c004a5 	addi.d	$r5,$r5,1(0x1)
9000000008000a04:	47ffe5bf 	bnez	$r13,-28(0x7fffe4) # 90000000080009e8 <strncpy+0x14>
    ;
  while (n-- > 0)
9000000008000a08:	0015018e 	move	$r14,$r12
9000000008000a0c:	0040818d 	slli.w	$r13,$r12,0x0
9000000008000a10:	6400200f 	bge	$r0,$r15,32(0x20) # 9000000008000a30 <strncpy+0x5c>
    *s++ = 0;
9000000008000a14:	02c005ce 	addi.d	$r14,$r14,1(0x1)
9000000008000a18:	293ffdc0 	st.b	$r0,$r14,-1(0xfff)
9000000008000a1c:	004081cc 	slli.w	$r12,$r14,0x0
9000000008000a20:	0014300c 	nor	$r12,$r0,$r12
9000000008000a24:	0010358c 	add.w	$r12,$r12,$r13
  while (n-- > 0)
9000000008000a28:	0010198c 	add.w	$r12,$r12,$r6
9000000008000a2c:	63ffe80c 	blt	$r0,$r12,-24(0x3ffe8) # 9000000008000a14 <strncpy+0x40>
  return os;
}
9000000008000a30:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000a34:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000a38:	4c000020 	jirl	$r0,$r1,0

9000000008000a3c <safestrcpy>:

// Like strncpy but guaranteed to NUL-terminate.
char *safestrcpy(char *s, const char *t, int n) {
9000000008000a3c:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000a40:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000a44:	02c04076 	addi.d	$r22,$r3,16(0x10)
  char *os;

  os = s;
  if (n <= 0)
9000000008000a48:	64003006 	bge	$r0,$r6,48(0x30) # 9000000008000a78 <safestrcpy+0x3c>
9000000008000a4c:	02bffcce 	addi.w	$r14,$r6,-1(0xfff)
9000000008000a50:	00df01ce 	bstrpick.d	$r14,$r14,0x1f,0x0
9000000008000a54:	0010b8ae 	add.d	$r14,$r5,$r14
9000000008000a58:	0015008c 	move	$r12,$r4
    return os;
  while (--n > 0 && (*s++ = *t++) != 0)
9000000008000a5c:	580018ae 	beq	$r5,$r14,24(0x18) # 9000000008000a74 <safestrcpy+0x38>
9000000008000a60:	02c004a5 	addi.d	$r5,$r5,1(0x1)
9000000008000a64:	02c0058c 	addi.d	$r12,$r12,1(0x1)
9000000008000a68:	283ffcad 	ld.b	$r13,$r5,-1(0xfff)
9000000008000a6c:	293ffd8d 	st.b	$r13,$r12,-1(0xfff)
9000000008000a70:	47ffedbf 	bnez	$r13,-20(0x7fffec) # 9000000008000a5c <safestrcpy+0x20>
    ;
  *s = 0;
9000000008000a74:	29000180 	st.b	$r0,$r12,0
  return os;
}
9000000008000a78:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000a7c:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000a80:	4c000020 	jirl	$r0,$r1,0

9000000008000a84 <strlen>:

int strlen(const char *s) {
9000000008000a84:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000a88:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000a8c:	02c04076 	addi.d	$r22,$r3,16(0x10)
  int n;

  for (n = 0; s[n]; n++)
9000000008000a90:	2800008c 	ld.b	$r12,$r4,0
9000000008000a94:	40003980 	beqz	$r12,56(0x38) # 9000000008000acc <strlen+0x48>
9000000008000a98:	02c00484 	addi.d	$r4,$r4,1(0x1)
9000000008000a9c:	0015008c 	move	$r12,$r4
9000000008000aa0:	00408084 	slli.w	$r4,$r4,0x0
9000000008000aa4:	0280040e 	addi.w	$r14,$r0,1(0x1)
9000000008000aa8:	001111ce 	sub.w	$r14,$r14,$r4
    ;
9000000008000aac:	00408184 	slli.w	$r4,$r12,0x0
9000000008000ab0:	001011c4 	add.w	$r4,$r14,$r4
9000000008000ab4:	02c0058c 	addi.d	$r12,$r12,1(0x1)
  for (n = 0; s[n]; n++)
9000000008000ab8:	283ffd8d 	ld.b	$r13,$r12,-1(0xfff)
9000000008000abc:	47fff1bf 	bnez	$r13,-16(0x7ffff0) # 9000000008000aac <strlen+0x28>
  return n;
}
9000000008000ac0:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000ac4:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000ac8:	4c000020 	jirl	$r0,$r1,0
  for (n = 0; s[n]; n++)
9000000008000acc:	00150004 	move	$r4,$r0
9000000008000ad0:	53fff3ff 	b	-16(0xffffff0) # 9000000008000ac0 <strlen+0x3c>

9000000008000ad4 <wnstr>:

// convert uchar string into wide char string
void wnstr(wchar *dst, char const *src, int len) {
9000000008000ad4:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000ad8:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000adc:	02c04076 	addi.d	$r22,$r3,16(0x10)
  while (len-- && *src) {
9000000008000ae0:	0015008d 	move	$r13,$r4
9000000008000ae4:	40003cc0 	beqz	$r6,60(0x3c) # 9000000008000b20 <wnstr+0x4c>
9000000008000ae8:	280000ac 	ld.b	$r12,$r5,0
9000000008000aec:	40003580 	beqz	$r12,52(0x34) # 9000000008000b20 <wnstr+0x4c>
9000000008000af0:	02bffccd 	addi.w	$r13,$r6,-1(0xfff)
9000000008000af4:	00df01ad 	bstrpick.d	$r13,$r13,0x1f,0x0
9000000008000af8:	002c01ad 	alsl.d	$r13,$r13,$r0,0x1
9000000008000afc:	02c009ad 	addi.d	$r13,$r13,2(0x2)
9000000008000b00:	0010b48d 	add.d	$r13,$r4,$r13
    *(uchar *)dst = *src++;
9000000008000b04:	02c004a5 	addi.d	$r5,$r5,1(0x1)
9000000008000b08:	2900008c 	st.b	$r12,$r4,0
    dst++;
9000000008000b0c:	02c00884 	addi.d	$r4,$r4,2(0x2)
  while (len-- && *src) {
9000000008000b10:	5800108d 	beq	$r4,$r13,16(0x10) # 9000000008000b20 <wnstr+0x4c>
9000000008000b14:	280000ac 	ld.b	$r12,$r5,0
9000000008000b18:	47ffed9f 	bnez	$r12,-20(0x7fffec) # 9000000008000b04 <wnstr+0x30>
    dst++;
9000000008000b1c:	0015008d 	move	$r13,$r4
  }

  *dst = 0;
9000000008000b20:	294001a0 	st.h	$r0,$r13,0
}
9000000008000b24:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000b28:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000b2c:	4c000020 	jirl	$r0,$r1,0

9000000008000b30 <snstr>:

// convert wide char string into uchar string
void snstr(char *dst, wchar const *src, int len) {
9000000008000b30:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000b34:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000b38:	02c04076 	addi.d	$r22,$r3,16(0x10)
  while (len-- && *src) {
9000000008000b3c:	400078c0 	beqz	$r6,120(0x78) # 9000000008000bb4 <snstr+0x84>
9000000008000b40:	02bffccc 	addi.w	$r12,$r6,-1(0xfff)
9000000008000b44:	2a4000af 	ld.hu	$r15,$r5,0
9000000008000b48:	0015008d 	move	$r13,$r4
9000000008000b4c:	400049e0 	beqz	$r15,72(0x48) # 9000000008000b94 <snstr+0x64>
9000000008000b50:	02bffccd 	addi.w	$r13,$r6,-1(0xfff)
9000000008000b54:	00df01ad 	bstrpick.d	$r13,$r13,0x1f,0x0
9000000008000b58:	02c005ad 	addi.d	$r13,$r13,1(0x1)
9000000008000b5c:	0010b48d 	add.d	$r13,$r4,$r13
9000000008000b60:	0015008e 	move	$r14,$r4
9000000008000b64:	00408084 	slli.w	$r4,$r4,0x0
    *dst++ = (uchar)(*src & 0xff);
9000000008000b68:	02c005ce 	addi.d	$r14,$r14,1(0x1)
9000000008000b6c:	293ffdcf 	st.b	$r15,$r14,-1(0xfff)
    src++;
9000000008000b70:	02c008a5 	addi.d	$r5,$r5,2(0x2)
9000000008000b74:	004081cc 	slli.w	$r12,$r14,0x0
9000000008000b78:	0014300c 	nor	$r12,$r0,$r12
9000000008000b7c:	0010198c 	add.w	$r12,$r12,$r6
9000000008000b80:	0010308c 	add.w	$r12,$r4,$r12
  while (len-- && *src) {
9000000008000b84:	580011cd 	beq	$r14,$r13,16(0x10) # 9000000008000b94 <snstr+0x64>
9000000008000b88:	2a4000af 	ld.hu	$r15,$r5,0
9000000008000b8c:	47ffddff 	bnez	$r15,-36(0x7fffdc) # 9000000008000b68 <snstr+0x38>
    *dst++ = (uchar)(*src & 0xff);
9000000008000b90:	001501cd 	move	$r13,$r14
9000000008000b94:	02bffd8e 	addi.w	$r14,$r12,-1(0xfff)
9000000008000b98:	00df01ce 	bstrpick.d	$r14,$r14,0x1f,0x0
9000000008000b9c:	02c005ce 	addi.d	$r14,$r14,1(0x1)
9000000008000ba0:	0010b9ae 	add.d	$r14,$r13,$r14
  }
  while (len-- > 0)
9000000008000ba4:	6400100c 	bge	$r0,$r12,16(0x10) # 9000000008000bb4 <snstr+0x84>
    *dst++ = 0;
9000000008000ba8:	02c005ad 	addi.d	$r13,$r13,1(0x1)
9000000008000bac:	293ffda0 	st.b	$r0,$r13,-1(0xfff)
  while (len-- > 0)
9000000008000bb0:	5ffff9cd 	bne	$r14,$r13,-8(0x3fff8) # 9000000008000ba8 <snstr+0x78>
}
9000000008000bb4:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000bb8:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000bbc:	4c000020 	jirl	$r0,$r1,0

9000000008000bc0 <wcsncmp>:

int wcsncmp(wchar const *s1, wchar const *s2, int len) {
9000000008000bc0:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000bc4:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000bc8:	02c04076 	addi.d	$r22,$r3,16(0x10)
  int ret = 0;

  while (len-- && *s1) {
9000000008000bcc:	00df00c6 	bstrpick.d	$r6,$r6,0x1f,0x0
9000000008000bd0:	002c00c6 	alsl.d	$r6,$r6,$r0,0x1
9000000008000bd4:	001098a6 	add.d	$r6,$r5,$r6
9000000008000bd8:	580024a6 	beq	$r5,$r6,36(0x24) # 9000000008000bfc <wcsncmp+0x3c>
9000000008000bdc:	2a40008c 	ld.hu	$r12,$r4,0
9000000008000be0:	40002180 	beqz	$r12,32(0x20) # 9000000008000c00 <wcsncmp+0x40>
    ret = (int)(*s1++ - *s2++);
9000000008000be4:	02c00884 	addi.d	$r4,$r4,2(0x2)
9000000008000be8:	02c008a5 	addi.d	$r5,$r5,2(0x2)
9000000008000bec:	2a7ff8ad 	ld.hu	$r13,$r5,-2(0xffe)
9000000008000bf0:	0011358c 	sub.w	$r12,$r12,$r13
    if (ret)
9000000008000bf4:	43ffe59f 	beqz	$r12,-28(0x7fffe4) # 9000000008000bd8 <wcsncmp+0x18>
9000000008000bf8:	50000800 	b	8(0x8) # 9000000008000c00 <wcsncmp+0x40>
9000000008000bfc:	0015000c 	move	$r12,$r0
      break;
  }

  return ret;
}
9000000008000c00:	00150184 	move	$r4,$r12
9000000008000c04:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000c08:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000c0c:	4c000020 	jirl	$r0,$r1,0

9000000008000c10 <strchr>:

char *strchr(const char *s, char c) {
9000000008000c10:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000c14:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000c18:	02c04076 	addi.d	$r22,$r3,16(0x10)
  for (; *s; s++)
9000000008000c1c:	2800008e 	ld.b	$r14,$r4,0
9000000008000c20:	40003dc0 	beqz	$r14,60(0x3c) # 9000000008000c5c <strchr+0x4c>
9000000008000c24:	0015008d 	move	$r13,$r4
    if (*s == c)
9000000008000c28:	001500ac 	move	$r12,$r5
9000000008000c2c:	00150185 	move	$r5,$r12
9000000008000c30:	5800218e 	beq	$r12,$r14,32(0x20) # 9000000008000c50 <strchr+0x40>
  for (; *s; s++)
9000000008000c34:	02c005ad 	addi.d	$r13,$r13,1(0x1)
9000000008000c38:	280001ac 	ld.b	$r12,$r13,0
9000000008000c3c:	40001180 	beqz	$r12,16(0x10) # 9000000008000c4c <strchr+0x3c>
    if (*s == c)
9000000008000c40:	5ffff585 	bne	$r12,$r5,-12(0x3fff4) # 9000000008000c34 <strchr+0x24>
  for (; *s; s++)
9000000008000c44:	001501a4 	move	$r4,$r13
9000000008000c48:	50000800 	b	8(0x8) # 9000000008000c50 <strchr+0x40>
      return (char *)s;
  return 0;
9000000008000c4c:	00150004 	move	$r4,$r0
9000000008000c50:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000c54:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000c58:	4c000020 	jirl	$r0,$r1,0
  return 0;
9000000008000c5c:	00150004 	move	$r4,$r0
9000000008000c60:	53fff3ff 	b	-16(0xffffff0) # 9000000008000c50 <strchr+0x40>

9000000008000c64 <main>:
  asm volatile("addi.d %0, $tp, 0" : "=r" (x) );
9000000008000c64:	02c0004c 	addi.d	$r12,$r2,0
    // started = 1;
    while (1);
    
  } else {
    // other hart
    while (started == 0)
9000000008000c68:	1c0002ad 	pcaddu12i	$r13,21(0x15)
9000000008000c6c:	02d021ad 	addi.d	$r13,$r13,1032(0x408)
  if (r_tp() == 0) {
9000000008000c70:	40001180 	beqz	$r12,16(0x10) # 9000000008000c80 <main+0x1c>
    while (started == 0)
9000000008000c74:	288001ac 	ld.w	$r12,$r13,0
9000000008000c78:	43fffd9f 	beqz	$r12,-4(0x7ffffc) # 9000000008000c74 <main+0x10>
9000000008000c7c:	4c000020 	jirl	$r0,$r1,0
void main() {
9000000008000c80:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000c84:	29c02061 	st.d	$r1,$r3,8(0x8)
9000000008000c88:	29c00076 	st.d	$r22,$r3,0
9000000008000c8c:	02c04076 	addi.d	$r22,$r3,16(0x10)
    cpuinit();
9000000008000c90:	54002400 	bl	36(0x24) # 9000000008000cb4 <cpuinit>
    consoleinit();
9000000008000c94:	5400f400 	bl	244(0xf4) # 9000000008000d88 <consoleinit>
    printfinit(); // init a lock for printf
9000000008000c98:	57f803ff 	bl	-2048(0xffff800) # 9000000008000498 <printfinit>
    printf("test");
9000000008000c9c:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008000ca0:	02d05084 	addi.d	$r4,$r4,1044(0x414)
9000000008000ca4:	57f5cfff 	bl	-2612(0xffff5cc) # 9000000008000270 <printf>
    kinit();        // physical page allocator
9000000008000ca8:	54023c00 	bl	572(0x23c) # 9000000008000ee4 <kinit>
    kvminit();      // create kernel page table
9000000008000cac:	54076000 	bl	1888(0x760) # 900000000800140c <kvminit>
    while (1);
9000000008000cb0:	50000000 	b	0 # 9000000008000cb0 <main+0x4c>

9000000008000cb4 <cpuinit>:
//   printf("tp: %p\n", r_tp());
//   printf("ra: %p\n", r_ra());
//   printf("}\n");
// }

void cpuinit(void) {
9000000008000cb4:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000cb8:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000cbc:	02c04076 	addi.d	$r22,$r3,16(0x10)
  struct cpu *it;
  for (it = cpus; it < &cpus[NCPU]; it++) {
    it->proc = 0;
9000000008000cc0:	1c0002ac 	pcaddu12i	$r12,21(0x15)
9000000008000cc4:	02cee18c 	addi.d	$r12,$r12,952(0x3b8)
9000000008000cc8:	29c00180 	st.d	$r0,$r12,0
    it->intena = 0;
9000000008000ccc:	2981b180 	st.w	$r0,$r12,108(0x6c)
    it->noff = 0;
9000000008000cd0:	2981a180 	st.w	$r0,$r12,104(0x68)
    it->proc = 0;
9000000008000cd4:	29c1c180 	st.d	$r0,$r12,112(0x70)
    it->intena = 0;
9000000008000cd8:	29837180 	st.w	$r0,$r12,220(0xdc)
    it->noff = 0;
9000000008000cdc:	29836180 	st.w	$r0,$r12,216(0xd8)
  }
}
9000000008000ce0:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000ce4:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000ce8:	4c000020 	jirl	$r0,$r1,0

9000000008000cec <cpuid>:
// }

// Must be called with interrupts disabled,
// to prevent race with process being moved
// to a different CPU.
int cpuid() {
9000000008000cec:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000cf0:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000cf4:	02c04076 	addi.d	$r22,$r3,16(0x10)
9000000008000cf8:	02c00044 	addi.d	$r4,$r2,0
  int id = r_tp();
9000000008000cfc:	00408084 	slli.w	$r4,$r4,0x0
  return id;
}
9000000008000d00:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000d04:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000d08:	4c000020 	jirl	$r0,$r1,0

9000000008000d0c <mycpu>:

// Return this CPU's cpu struct.
// Interrupts must be disabled.
struct cpu *mycpu(void) {
9000000008000d0c:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000d10:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008000d14:	02c04076 	addi.d	$r22,$r3,16(0x10)
9000000008000d18:	02c0004c 	addi.d	$r12,$r2,0
  int id = r_tp();
9000000008000d1c:	0040818c 	slli.w	$r12,$r12,0x0
  int id = cpuid();
  struct cpu *c = &cpus[id];
9000000008000d20:	0281c004 	addi.w	$r4,$r0,112(0x70)
9000000008000d24:	001d918c 	mul.d	$r12,$r12,$r4

  return c;
}
9000000008000d28:	1c0002a4 	pcaddu12i	$r4,21(0x15)
9000000008000d2c:	02cd4084 	addi.d	$r4,$r4,848(0x350)
9000000008000d30:	0010b084 	add.d	$r4,$r4,$r12
9000000008000d34:	28c02076 	ld.d	$r22,$r3,8(0x8)
9000000008000d38:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000d3c:	4c000020 	jirl	$r0,$r1,0

9000000008000d40 <consputc>:
// #include "include/uart8250.h"

#define BACKSPACE 0x100
#define C(x) ((x) - '@') // Control-x

void consputc(int c) {
9000000008000d40:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000d44:	29c02061 	st.d	$r1,$r3,8(0x8)
9000000008000d48:	29c00076 	st.d	$r22,$r3,0
9000000008000d4c:	02c04076 	addi.d	$r22,$r3,16(0x10)
  if (c == BACKSPACE) {
9000000008000d50:	0284000c 	addi.w	$r12,$r0,256(0x100)
9000000008000d54:	5800188c 	beq	$r4,$r12,24(0x18) # 9000000008000d6c <consputc+0x2c>
    // if the user typed backspace, overwrite with a space.
    uartputc_sync('\b');
    uartputc_sync(' ');
    uartputc_sync('\b');
  } else {
    uartputc_sync(c);
9000000008000d58:	57f803ff 	bl	-2048(0xffff800) # 9000000008000558 <uartputc_sync>
  }
}
9000000008000d5c:	28c02061 	ld.d	$r1,$r3,8(0x8)
9000000008000d60:	28c00076 	ld.d	$r22,$r3,0
9000000008000d64:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000d68:	4c000020 	jirl	$r0,$r1,0
    uartputc_sync('\b');
9000000008000d6c:	02802004 	addi.w	$r4,$r0,8(0x8)
9000000008000d70:	57f7ebff 	bl	-2072(0xffff7e8) # 9000000008000558 <uartputc_sync>
    uartputc_sync(' ');
9000000008000d74:	02808004 	addi.w	$r4,$r0,32(0x20)
9000000008000d78:	57f7e3ff 	bl	-2080(0xffff7e0) # 9000000008000558 <uartputc_sync>
    uartputc_sync('\b');
9000000008000d7c:	02802004 	addi.w	$r4,$r0,8(0x8)
9000000008000d80:	57f7dbff 	bl	-2088(0xffff7d8) # 9000000008000558 <uartputc_sync>
9000000008000d84:	53ffdbff 	b	-40(0xfffffd8) # 9000000008000d5c <consputc+0x1c>

9000000008000d88 <consoleinit>:
//   }

//   release(&cons.lock);
// }

void consoleinit(void) {
9000000008000d88:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008000d8c:	29c02061 	st.d	$r1,$r3,8(0x8)
9000000008000d90:	29c00076 	st.d	$r22,$r3,0
9000000008000d94:	02c04076 	addi.d	$r22,$r3,16(0x10)
  initlock(&cons.lock, "cons");
9000000008000d98:	1c000045 	pcaddu12i	$r5,2(0x2)
9000000008000d9c:	02cc80a5 	addi.d	$r5,$r5,800(0x320)
9000000008000da0:	1c0002a4 	pcaddu12i	$r4,21(0x15)
9000000008000da4:	02cee084 	addi.d	$r4,$r4,952(0x3b8)
9000000008000da8:	57f94bff 	bl	-1720(0xffff948) # 90000000080006f0 <initlock>
// #ifdef QEMU
  uartinit();
9000000008000dac:	57f733ff 	bl	-2256(0xffff730) # 90000000080004dc <uartinit>
// #endif
// #ifdef visionfive
//   uart8250_init(UART, 24000000, 115200, 2, 4, 0);
// #endif
  cons.e = cons.w = cons.r = 0;
9000000008000db0:	1c0002ac 	pcaddu12i	$r12,21(0x15)
9000000008000db4:	02cea18c 	addi.d	$r12,$r12,936(0x3a8)
9000000008000db8:	29826180 	st.w	$r0,$r12,152(0x98)
9000000008000dbc:	29827180 	st.w	$r0,$r12,156(0x9c)
9000000008000dc0:	29828180 	st.w	$r0,$r12,160(0xa0)

  // connect read and write system calls
  // to consoleread and consolewrite.
//  devsw[CONSOLE].read = consoleread;
//  devsw[CONSOLE].write = consolewrite;
}
9000000008000dc4:	28c02061 	ld.d	$r1,$r3,8(0x8)
9000000008000dc8:	28c00076 	ld.d	$r22,$r3,0
9000000008000dcc:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008000dd0:	4c000020 	jirl	$r0,$r1,0

9000000008000dd4 <kfree>:
// which normally should have been returned by a
// call to kalloc().  (The exception is when
// initializing the allocator; 
// see kinit above.)

void kfree(void *pa) {
9000000008000dd4:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008000dd8:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008000ddc:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008000de0:	29c02077 	st.d	$r23,$r3,8(0x8)
9000000008000de4:	02c08076 	addi.d	$r22,$r3,32(0x20)
  struct run *r;

  if (((uint64)pa % PGSIZE) != 0 || (char *)pa < kernel_end ||
9000000008000de8:	037ffc8c 	andi	$r12,$r4,0xfff
9000000008000dec:	44007580 	bnez	$r12,116(0x74) # 9000000008000e60 <kfree+0x8c>
9000000008000df0:	00150097 	move	$r23,$r4
9000000008000df4:	1c00008c 	pcaddu12i	$r12,4(0x4)
9000000008000df8:	28c8b18c 	ld.d	$r12,$r12,556(0x22c)
9000000008000dfc:	6800648c 	bltu	$r4,$r12,100(0x64) # 9000000008000e60 <kfree+0x8c>
9000000008000e00:	1530000c 	lu12i.w	$r12,-425984(0x98000)
9000000008000e04:	1600000c 	lu32i.d	$r12,0
9000000008000e08:	0324018c 	lu52i.d	$r12,$r12,-1792(0x900)
9000000008000e0c:	6c00548c 	bgeu	$r4,$r12,84(0x54) # 9000000008000e60 <kfree+0x8c>
      (uint64)pa >= RAMSTOP)
    panic("kfree");

  // Fill with junk to catch dangling refs.
  memset(pa, 1, PGSIZE);
9000000008000e10:	14000026 	lu12i.w	$r6,1(0x1)
9000000008000e14:	02800405 	addi.w	$r5,$r0,1(0x1)
9000000008000e18:	57f9fbff 	bl	-1544(0xffff9f8) # 9000000008000810 <memset>

  r = (struct run *)pa;

  acquire(&kmem.lock);
9000000008000e1c:	1c0002a4 	pcaddu12i	$r4,21(0x15)
9000000008000e20:	02cf9084 	addi.d	$r4,$r4,996(0x3e4)
9000000008000e24:	57f93bff 	bl	-1736(0xffff938) # 900000000800075c <acquire>
  r->next = kmem.freelist;
9000000008000e28:	1c0002a4 	pcaddu12i	$r4,21(0x15)
9000000008000e2c:	02cf6084 	addi.d	$r4,$r4,984(0x3d8)
9000000008000e30:	28c0608c 	ld.d	$r12,$r4,24(0x18)
9000000008000e34:	29c002ec 	st.d	$r12,$r23,0
  kmem.freelist = r;
9000000008000e38:	29c06097 	st.d	$r23,$r4,24(0x18)
  kmem.npage++;
9000000008000e3c:	28c0808c 	ld.d	$r12,$r4,32(0x20)
9000000008000e40:	02c0058c 	addi.d	$r12,$r12,1(0x1)
9000000008000e44:	29c0808c 	st.d	$r12,$r4,32(0x20)
  release(&kmem.lock);
9000000008000e48:	57f977ff 	bl	-1676(0xffff974) # 90000000080007bc <release>
}
9000000008000e4c:	28c06061 	ld.d	$r1,$r3,24(0x18)
9000000008000e50:	28c04076 	ld.d	$r22,$r3,16(0x10)
9000000008000e54:	28c02077 	ld.d	$r23,$r3,8(0x8)
9000000008000e58:	02c08063 	addi.d	$r3,$r3,32(0x20)
9000000008000e5c:	4c000020 	jirl	$r0,$r1,0
    panic("kfree");
9000000008000e60:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008000e64:	02c98084 	addi.d	$r4,$r4,608(0x260)
9000000008000e68:	57f39bff 	bl	-3176(0xffff398) # 9000000008000200 <panic>

9000000008000e6c <freerange>:
void freerange(void *pa_start, void *pa_end) {
9000000008000e6c:	02ff4063 	addi.d	$r3,$r3,-48(0xfd0)
9000000008000e70:	29c0a061 	st.d	$r1,$r3,40(0x28)
9000000008000e74:	29c08076 	st.d	$r22,$r3,32(0x20)
9000000008000e78:	29c06077 	st.d	$r23,$r3,24(0x18)
9000000008000e7c:	29c04078 	st.d	$r24,$r3,16(0x10)
9000000008000e80:	29c02079 	st.d	$r25,$r3,8(0x8)
9000000008000e84:	29c0007a 	st.d	$r26,$r3,0
9000000008000e88:	02c0c076 	addi.d	$r22,$r3,48(0x30)
  p = (char *)PGROUNDUP((uint64)pa_start);
9000000008000e8c:	03bffc17 	ori	$r23,$r0,0xfff
9000000008000e90:	0010dc97 	add.d	$r23,$r4,$r23
9000000008000e94:	15ffffe4 	lu12i.w	$r4,-1(0xfffff)
9000000008000e98:	001492f7 	and	$r23,$r23,$r4
  for (; p + PGSIZE <= (char *)pa_end; p += PGSIZE)
9000000008000e9c:	14000024 	lu12i.w	$r4,1(0x1)
9000000008000ea0:	001092f7 	add.d	$r23,$r23,$r4
9000000008000ea4:	680020b7 	bltu	$r5,$r23,32(0x20) # 9000000008000ec4 <freerange+0x58>
9000000008000ea8:	001500b8 	move	$r24,$r5
    kfree(p);
9000000008000eac:	15fffffa 	lu12i.w	$r26,-1(0xfffff)
  for (; p + PGSIZE <= (char *)pa_end; p += PGSIZE)
9000000008000eb0:	14000039 	lu12i.w	$r25,1(0x1)
    kfree(p);
9000000008000eb4:	0010eae4 	add.d	$r4,$r23,$r26
9000000008000eb8:	57ff1fff 	bl	-228(0xfffff1c) # 9000000008000dd4 <kfree>
  for (; p + PGSIZE <= (char *)pa_end; p += PGSIZE)
9000000008000ebc:	0010e6f7 	add.d	$r23,$r23,$r25
9000000008000ec0:	6ffff717 	bgeu	$r24,$r23,-12(0x3fff4) # 9000000008000eb4 <freerange+0x48>
}
9000000008000ec4:	28c0a061 	ld.d	$r1,$r3,40(0x28)
9000000008000ec8:	28c08076 	ld.d	$r22,$r3,32(0x20)
9000000008000ecc:	28c06077 	ld.d	$r23,$r3,24(0x18)
9000000008000ed0:	28c04078 	ld.d	$r24,$r3,16(0x10)
9000000008000ed4:	28c02079 	ld.d	$r25,$r3,8(0x8)
9000000008000ed8:	28c0007a 	ld.d	$r26,$r3,0
9000000008000edc:	02c0c063 	addi.d	$r3,$r3,48(0x30)
9000000008000ee0:	4c000020 	jirl	$r0,$r1,0

9000000008000ee4 <kinit>:
void kinit() {
9000000008000ee4:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008000ee8:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008000eec:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008000ef0:	29c02077 	st.d	$r23,$r3,8(0x8)
9000000008000ef4:	02c08076 	addi.d	$r22,$r3,32(0x20)
  initlock(&kmem.lock, "kmem");
9000000008000ef8:	1c000045 	pcaddu12i	$r5,2(0x2)
9000000008000efc:	02c740a5 	addi.d	$r5,$r5,464(0x1d0)
9000000008000f00:	1c0002a4 	pcaddu12i	$r4,21(0x15)
9000000008000f04:	02cc0084 	addi.d	$r4,$r4,768(0x300)
9000000008000f08:	57f7ebff 	bl	-2072(0xffff7e8) # 90000000080006f0 <initlock>
  kmem.freelist = 0;
9000000008000f0c:	1c0002ac 	pcaddu12i	$r12,21(0x15)
9000000008000f10:	02cbd18c 	addi.d	$r12,$r12,756(0x2f4)
9000000008000f14:	29c06180 	st.d	$r0,$r12,24(0x18)
  kmem.npage = 0;
9000000008000f18:	29c08180 	st.d	$r0,$r12,32(0x20)
  freerange(kernel_end, (void *)RAMSTOP);
9000000008000f1c:	15300017 	lu12i.w	$r23,-425984(0x98000)
9000000008000f20:	16000017 	lu32i.d	$r23,0
9000000008000f24:	032402f7 	lu52i.d	$r23,$r23,-1792(0x900)
9000000008000f28:	001502e5 	move	$r5,$r23
9000000008000f2c:	1c000084 	pcaddu12i	$r4,4(0x4)
9000000008000f30:	28c3d084 	ld.d	$r4,$r4,244(0xf4)
9000000008000f34:	57ff3bff 	bl	-200(0xfffff38) # 9000000008000e6c <freerange>
  printf("kernel_end: %p, RAMSTOP: %p\n", kernel_end, (void *)RAMSTOP);
9000000008000f38:	001502e6 	move	$r6,$r23
9000000008000f3c:	1c000085 	pcaddu12i	$r5,4(0x4)
9000000008000f40:	28c390a5 	ld.d	$r5,$r5,228(0xe4)
9000000008000f44:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008000f48:	02c63084 	addi.d	$r4,$r4,396(0x18c)
9000000008000f4c:	57f327ff 	bl	-3292(0xffff324) # 9000000008000270 <printf>
}
9000000008000f50:	28c06061 	ld.d	$r1,$r3,24(0x18)
9000000008000f54:	28c04076 	ld.d	$r22,$r3,16(0x10)
9000000008000f58:	28c02077 	ld.d	$r23,$r3,8(0x8)
9000000008000f5c:	02c08063 	addi.d	$r3,$r3,32(0x20)
9000000008000f60:	4c000020 	jirl	$r0,$r1,0

9000000008000f64 <kalloc>:

// Allocate one 4096-byte page of physical memory.
// Returns a pointer that the kernel can use.
// Returns 0 if the memory cannot be allocated.
void *kalloc(void) {
9000000008000f64:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008000f68:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008000f6c:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008000f70:	29c02077 	st.d	$r23,$r3,8(0x8)
9000000008000f74:	02c08076 	addi.d	$r22,$r3,32(0x20)
  struct run *r;

  acquire(&kmem.lock);
9000000008000f78:	1c0002a4 	pcaddu12i	$r4,21(0x15)
9000000008000f7c:	02ca2084 	addi.d	$r4,$r4,648(0x288)
9000000008000f80:	57f7dfff 	bl	-2084(0xffff7dc) # 900000000800075c <acquire>
  r = kmem.freelist;
9000000008000f84:	1c0002ac 	pcaddu12i	$r12,21(0x15)
9000000008000f88:	02c9f18c 	addi.d	$r12,$r12,636(0x27c)
9000000008000f8c:	28c06197 	ld.d	$r23,$r12,24(0x18)
  if (r) {
9000000008000f90:	40004ee0 	beqz	$r23,76(0x4c) # 9000000008000fdc <kalloc+0x78>
    // 自由链表块数量减少
    kmem.freelist = r->next;
9000000008000f94:	28c002ec 	ld.d	$r12,$r23,0
9000000008000f98:	1c0002a4 	pcaddu12i	$r4,21(0x15)
9000000008000f9c:	02c9a084 	addi.d	$r4,$r4,616(0x268)
9000000008000fa0:	29c0608c 	st.d	$r12,$r4,24(0x18)
    // 可用页数减少
    kmem.npage--;
9000000008000fa4:	28c0808c 	ld.d	$r12,$r4,32(0x20)
9000000008000fa8:	02fffd8c 	addi.d	$r12,$r12,-1(0xfff)
9000000008000fac:	29c0808c 	st.d	$r12,$r4,32(0x20)
  }
  release(&kmem.lock);
9000000008000fb0:	57f80fff 	bl	-2036(0xffff80c) # 90000000080007bc <release>

  if (r)
    memset((char *)r, 5, PGSIZE); // fill with junk
9000000008000fb4:	14000026 	lu12i.w	$r6,1(0x1)
9000000008000fb8:	02801405 	addi.w	$r5,$r0,5(0x5)
9000000008000fbc:	001502e4 	move	$r4,$r23
9000000008000fc0:	57f853ff 	bl	-1968(0xffff850) # 9000000008000810 <memset>
  else {
    printf("kalloc out of memory\n");
  }
  return (void *)r;
}
9000000008000fc4:	001502e4 	move	$r4,$r23
9000000008000fc8:	28c06061 	ld.d	$r1,$r3,24(0x18)
9000000008000fcc:	28c04076 	ld.d	$r22,$r3,16(0x10)
9000000008000fd0:	28c02077 	ld.d	$r23,$r3,8(0x8)
9000000008000fd4:	02c08063 	addi.d	$r3,$r3,32(0x20)
9000000008000fd8:	4c000020 	jirl	$r0,$r1,0
  release(&kmem.lock);
9000000008000fdc:	1c0002a4 	pcaddu12i	$r4,21(0x15)
9000000008000fe0:	02c89084 	addi.d	$r4,$r4,548(0x224)
9000000008000fe4:	57f7dbff 	bl	-2088(0xffff7d8) # 90000000080007bc <release>
    printf("kalloc out of memory\n");
9000000008000fe8:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008000fec:	02c42084 	addi.d	$r4,$r4,264(0x108)
9000000008000ff0:	57f283ff 	bl	-3456(0xffff280) # 9000000008000270 <printf>
9000000008000ff4:	53ffd3ff 	b	-48(0xfffffd0) # 9000000008000fc4 <kalloc+0x60>

9000000008000ff8 <freemem_amount>:
// 获取系统内可用的内存数量
uint64 freemem_amount(void) {
9000000008000ff8:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008000ffc:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008001000:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008001004:	29c02077 	st.d	$r23,$r3,8(0x8)
9000000008001008:	02c08076 	addi.d	$r22,$r3,32(0x20)
  uint64 amount = 0;
  // 内核内存锁
  acquire(&kmem.lock);
900000000800100c:	1c0002a4 	pcaddu12i	$r4,21(0x15)
9000000008001010:	02c7d084 	addi.d	$r4,$r4,500(0x1f4)
9000000008001014:	57f74bff 	bl	-2232(0xffff748) # 900000000800075c <acquire>
  amount = kmem.npage;
9000000008001018:	1c0002a4 	pcaddu12i	$r4,21(0x15)
900000000800101c:	02c7a084 	addi.d	$r4,$r4,488(0x1e8)
9000000008001020:	28c08097 	ld.d	$r23,$r4,32(0x20)
  release(&kmem.lock);
9000000008001024:	57f79bff 	bl	-2152(0xffff798) # 90000000080007bc <release>
  // 将页转换为字节数
  // PGSHIFT = 12, size for mem = 4k
  return amount << PGSHIFT;
}
9000000008001028:	004132e4 	slli.d	$r4,$r23,0xc
900000000800102c:	28c06061 	ld.d	$r1,$r3,24(0x18)
9000000008001030:	28c04076 	ld.d	$r22,$r3,16(0x10)
9000000008001034:	28c02077 	ld.d	$r23,$r3,8(0x8)
9000000008001038:	02c08063 	addi.d	$r3,$r3,32(0x20)
900000000800103c:	4c000020 	jirl	$r0,$r1,0

9000000008001040 <tlbinit>:
}
// flush tlb, fill '0'

void
tlbinit(void)
{
9000000008001040:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008001044:	29c02076 	st.d	$r22,$r3,8(0x8)
9000000008001048:	02c04076 	addi.d	$r22,$r3,16(0x10)
  asm volatile("invtlb  0x0,$zero,$zero");
900000000800104c:	06498000 	invtlb	0x0,$r0,$r0
  asm volatile("csrwr %0, 0x1e" : : "r" (x) );
9000000008001050:	0280300c 	addi.w	$r12,$r0,12(0xc)
9000000008001054:	0400782c 	csrwr	$r12,0x1e
  asm volatile("csrwr %0, 0x18" : : "r" (x) );
9000000008001058:	0015000c 	move	$r12,$r0
900000000800105c:	0400602c 	csrwr	$r12,0x18
  asm volatile("csrwr %0, 0x8e" : : "r" (x) );
9000000008001060:	0280300c 	addi.w	$r12,$r0,12(0xc)
9000000008001064:	0402382c 	csrwr	$r12,0x8e
  w_csr_stlbps(0xcU);// reset
  w_csr_asid(0x0U);
  w_csr_tlbrehi(0xcU);
}
9000000008001068:	28c02076 	ld.d	$r22,$r3,8(0x8)
900000000800106c:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008001070:	4c000020 	jirl	$r0,$r1,0

9000000008001074 <walk>:
//   30..38 -- 9 bits of level-2 index.
//   21..29 -- 9 bits of level-1 index.
//   12..20 -- 9 bits of level-0 index.
//    0..11 -- 12 bits of byte offset within the page.
// 
pte_t *walk(pagetable_t pagetable, uint64 va, int alloc) {
9000000008001074:	02fec063 	addi.d	$r3,$r3,-80(0xfb0)
9000000008001078:	29c12061 	st.d	$r1,$r3,72(0x48)
900000000800107c:	29c10076 	st.d	$r22,$r3,64(0x40)
9000000008001080:	29c0e077 	st.d	$r23,$r3,56(0x38)
9000000008001084:	29c0c078 	st.d	$r24,$r3,48(0x30)
9000000008001088:	29c0a079 	st.d	$r25,$r3,40(0x28)
900000000800108c:	29c0807a 	st.d	$r26,$r3,32(0x20)
9000000008001090:	29c0607b 	st.d	$r27,$r3,24(0x18)
9000000008001094:	29c0407c 	st.d	$r28,$r3,16(0x10)
9000000008001098:	29c0207d 	st.d	$r29,$r3,8(0x8)
900000000800109c:	02c14076 	addi.d	$r22,$r3,80(0x50)
90000000080010a0:	00150097 	move	$r23,$r4
90000000080010a4:	001500ba 	move	$r26,$r5
90000000080010a8:	001500dd 	move	$r29,$r6

  if (va >= MAXVA)
90000000080010ac:	1400200c 	lu12i.w	$r12,256(0x100)
90000000080010b0:	02809c19 	addi.w	$r25,$r0,39(0x27)

  for (int level = 3; level > 0; level--) {
    pte_t *pte = &pagetable[PX(level, va)];
    if (*pte & PTE_V) {
      // 内核转换为物理地址
      pagetable = (pagetable_t)(PTE2PA(*pte) | DMWIN_MASK);
90000000080010b4:	0324001c 	lu52i.d	$r28,$r0,-1792(0x900)
  for (int level = 3; level > 0; level--) {
90000000080010b8:	0280301b 	addi.w	$r27,$r0,12(0xc)
  if (va >= MAXVA)
90000000080010bc:	680048ac 	bltu	$r5,$r12,72(0x48) # 9000000008001104 <walk+0x90>
    panic("walk");
90000000080010c0:	1c000044 	pcaddu12i	$r4,2(0x2)
90000000080010c4:	02c12084 	addi.d	$r4,$r4,72(0x48)
90000000080010c8:	57f13bff 	bl	-3784(0xffff138) # 9000000008000200 <panic>
    } else {
      if (!alloc || (pagetable = (pde_t *)kalloc()) == NULL) {
90000000080010cc:	40009ba0 	beqz	$r29,152(0x98) # 9000000008001164 <walk+0xf0>
90000000080010d0:	57fe97ff 	bl	-364(0xffffe94) # 9000000008000f64 <kalloc>
90000000080010d4:	00150097 	move	$r23,$r4
90000000080010d8:	40006080 	beqz	$r4,96(0x60) # 9000000008001138 <walk+0xc4>
        // printf("walk: not valid\n");
        return NULL;
      }
      memset(pagetable, 0, PGSIZE);
90000000080010dc:	14000026 	lu12i.w	$r6,1(0x1)
90000000080010e0:	00150005 	move	$r5,$r0
90000000080010e4:	57f72fff 	bl	-2260(0xffff72c) # 9000000008000810 <memset>
      *pte = PA2PTE(pagetable) | PTE_V;
90000000080010e8:	15ffffec 	lu12i.w	$r12,-1(0xfffff)
90000000080010ec:	161fffec 	lu32i.d	$r12,65535(0xffff)
90000000080010f0:	0014b2ec 	and	$r12,$r23,$r12
90000000080010f4:	0380058c 	ori	$r12,$r12,0x1
90000000080010f8:	29c0030c 	st.d	$r12,$r24,0
90000000080010fc:	02bfdf39 	addi.w	$r25,$r25,-9(0xff7)
  for (int level = 3; level > 0; level--) {
9000000008001100:	5800333b 	beq	$r25,$r27,48(0x30) # 9000000008001130 <walk+0xbc>
    pte_t *pte = &pagetable[PX(level, va)];
9000000008001104:	00196758 	srl.d	$r24,$r26,$r25
9000000008001108:	0347ff18 	andi	$r24,$r24,0x1ff
900000000800110c:	002d5f18 	alsl.d	$r24,$r24,$r23,0x3
    if (*pte & PTE_V) {
9000000008001110:	28c00317 	ld.d	$r23,$r24,0
9000000008001114:	034006ec 	andi	$r12,$r23,0x1
9000000008001118:	43ffb59f 	beqz	$r12,-76(0x7fffb4) # 90000000080010cc <walk+0x58>
      pagetable = (pagetable_t)(PTE2PA(*pte) | DMWIN_MASK);
900000000800111c:	15ffffe4 	lu12i.w	$r4,-1(0xfffff)
9000000008001120:	161fffe4 	lu32i.d	$r4,65535(0xffff)
9000000008001124:	001492f7 	and	$r23,$r23,$r4
9000000008001128:	001572f7 	or	$r23,$r23,$r28
900000000800112c:	53ffd3ff 	b	-48(0xfffffd0) # 90000000080010fc <walk+0x88>
    }
  }
  return &pagetable[PX(0, va)];
9000000008001130:	00453344 	srli.d	$r4,$r26,0xc
9000000008001134:	002d5c84 	alsl.d	$r4,$r4,$r23,0x3
}
9000000008001138:	28c12061 	ld.d	$r1,$r3,72(0x48)
900000000800113c:	28c10076 	ld.d	$r22,$r3,64(0x40)
9000000008001140:	28c0e077 	ld.d	$r23,$r3,56(0x38)
9000000008001144:	28c0c078 	ld.d	$r24,$r3,48(0x30)
9000000008001148:	28c0a079 	ld.d	$r25,$r3,40(0x28)
900000000800114c:	28c0807a 	ld.d	$r26,$r3,32(0x20)
9000000008001150:	28c0607b 	ld.d	$r27,$r3,24(0x18)
9000000008001154:	28c0407c 	ld.d	$r28,$r3,16(0x10)
9000000008001158:	28c0207d 	ld.d	$r29,$r3,8(0x8)
900000000800115c:	02c14063 	addi.d	$r3,$r3,80(0x50)
9000000008001160:	4c000020 	jirl	$r0,$r1,0
        return NULL;
9000000008001164:	00150004 	move	$r4,$r0
9000000008001168:	53ffd3ff 	b	-48(0xfffffd0) # 9000000008001138 <walk+0xc4>

900000000800116c <walkaddr>:

// Look up a virtual address, return the physical address,
// or 0 if not mapped.
// Can only be used to look up user pages.
uint64 walkaddr(pagetable_t pagetable, uint64 va) {
900000000800116c:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008001170:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008001174:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008001178:	29c02077 	st.d	$r23,$r3,8(0x8)
900000000800117c:	29c00078 	st.d	$r24,$r3,0
9000000008001180:	02c08076 	addi.d	$r22,$r3,32(0x20)
  pte_t *pte;
  uint64 pa;

  if (va >= MAXVA) {
9000000008001184:	1400200c 	lu12i.w	$r12,256(0x100)
9000000008001188:	6c0050ac 	bgeu	$r5,$r12,80(0x50) # 90000000080011d8 <walkaddr+0x6c>
900000000800118c:	001500b8 	move	$r24,$r5
    // debug_print --> printf
    printf("walkaddr: va >= MAXVA\n");
    return NULL;
  }

  pte = walk(pagetable, va, 0);
9000000008001190:	00150006 	move	$r6,$r0
9000000008001194:	57fee3ff 	bl	-288(0xffffee0) # 9000000008001074 <walk>
  if (pte == 0) {
9000000008001198:	40005480 	beqz	$r4,84(0x54) # 90000000080011ec <walkaddr+0x80>
    printf("walkaddr: pte == 0\n");
    return NULL;
  }
  if ((*pte & PTE_V) == 0) {
900000000800119c:	28c0008c 	ld.d	$r12,$r4,0
90000000080011a0:	03400597 	andi	$r23,$r12,0x1
90000000080011a4:	40005ee0 	beqz	$r23,92(0x5c) # 9000000008001200 <walkaddr+0x94>
    printf("va :%p walkaddr: *pte & PTE_V == 0\n", va);
    return NULL;
  }
  if ((*pte & PTE_PLV) == 0) {
90000000080011a8:	03403197 	andi	$r23,$r12,0xc
90000000080011ac:	40006ae0 	beqz	$r23,104(0x68) # 9000000008001214 <walkaddr+0xa8>
    printf("walkaddr: *pte & PTE_U == 0\n");
    return NULL;
  }
  // Used when in user_mode
  pa = PTE2PA(*pte);
90000000080011b0:	15fffff7 	lu12i.w	$r23,-1(0xfffff)
90000000080011b4:	161ffff7 	lu32i.d	$r23,65535(0xffff)
90000000080011b8:	0014dd97 	and	$r23,$r12,$r23
  return pa;
}
90000000080011bc:	001502e4 	move	$r4,$r23
90000000080011c0:	28c06061 	ld.d	$r1,$r3,24(0x18)
90000000080011c4:	28c04076 	ld.d	$r22,$r3,16(0x10)
90000000080011c8:	28c02077 	ld.d	$r23,$r3,8(0x8)
90000000080011cc:	28c00078 	ld.d	$r24,$r3,0
90000000080011d0:	02c08063 	addi.d	$r3,$r3,32(0x20)
90000000080011d4:	4c000020 	jirl	$r0,$r1,0
    printf("walkaddr: va >= MAXVA\n");
90000000080011d8:	1c000044 	pcaddu12i	$r4,2(0x2)
90000000080011dc:	02fce084 	addi.d	$r4,$r4,-200(0xf38)
90000000080011e0:	57f093ff 	bl	-3952(0xffff090) # 9000000008000270 <printf>
    return NULL;
90000000080011e4:	00150017 	move	$r23,$r0
90000000080011e8:	53ffd7ff 	b	-44(0xfffffd4) # 90000000080011bc <walkaddr+0x50>
    printf("walkaddr: pte == 0\n");
90000000080011ec:	1c000044 	pcaddu12i	$r4,2(0x2)
90000000080011f0:	02fcf084 	addi.d	$r4,$r4,-196(0xf3c)
90000000080011f4:	57f07fff 	bl	-3972(0xffff07c) # 9000000008000270 <printf>
    return NULL;
90000000080011f8:	00150017 	move	$r23,$r0
90000000080011fc:	53ffc3ff 	b	-64(0xfffffc0) # 90000000080011bc <walkaddr+0x50>
    printf("va :%p walkaddr: *pte & PTE_V == 0\n", va);
9000000008001200:	00150305 	move	$r5,$r24
9000000008001204:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008001208:	02fcf084 	addi.d	$r4,$r4,-196(0xf3c)
900000000800120c:	57f067ff 	bl	-3996(0xffff064) # 9000000008000270 <printf>
    return NULL;
9000000008001210:	53ffafff 	b	-84(0xfffffac) # 90000000080011bc <walkaddr+0x50>
    printf("walkaddr: *pte & PTE_U == 0\n");
9000000008001214:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008001218:	02fd5084 	addi.d	$r4,$r4,-172(0xf54)
900000000800121c:	57f057ff 	bl	-4012(0xffff054) # 9000000008000270 <printf>
    return NULL;
9000000008001220:	53ff9fff 	b	-100(0xfffff9c) # 90000000080011bc <walkaddr+0x50>

9000000008001224 <kwalkaddr>:
// a physical address. only needed for
// addresses on the stack.
// assumes va is page aligned.
uint64 kvmpa(uint64 va) { return kwalkaddr(kernel_pagetable, va); }

uint64 kwalkaddr(pagetable_t kpt, uint64 va) {
9000000008001224:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008001228:	29c06061 	st.d	$r1,$r3,24(0x18)
900000000800122c:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008001230:	29c02077 	st.d	$r23,$r3,8(0x8)
9000000008001234:	02c08076 	addi.d	$r22,$r3,32(0x20)
  uint64 off = va % PGSIZE;
9000000008001238:	037ffcb7 	andi	$r23,$r5,0xfff
  pte_t *pte;
  uint64 pa;

  pte = walk(kpt, va, 0);
900000000800123c:	00150006 	move	$r6,$r0
9000000008001240:	57fe37ff 	bl	-460(0xffffe34) # 9000000008001074 <walk>
  if (pte == 0)
9000000008001244:	40003480 	beqz	$r4,52(0x34) # 9000000008001278 <kwalkaddr+0x54>
    panic("kvmpa");
  if ((*pte & PTE_V) == 0)
9000000008001248:	28c00084 	ld.d	$r4,$r4,0
900000000800124c:	0340048c 	andi	$r12,$r4,0x1
9000000008001250:	40003580 	beqz	$r12,52(0x34) # 9000000008001284 <kwalkaddr+0x60>
    panic("kvmpa");
  pa = PTE2PA(*pte);
9000000008001254:	15ffffec 	lu12i.w	$r12,-1(0xfffff)
9000000008001258:	161fffec 	lu32i.d	$r12,65535(0xffff)
900000000800125c:	0014b084 	and	$r4,$r4,$r12
  return pa + off;
}
9000000008001260:	00155c84 	or	$r4,$r4,$r23
9000000008001264:	28c06061 	ld.d	$r1,$r3,24(0x18)
9000000008001268:	28c04076 	ld.d	$r22,$r3,16(0x10)
900000000800126c:	28c02077 	ld.d	$r23,$r3,8(0x8)
9000000008001270:	02c08063 	addi.d	$r3,$r3,32(0x20)
9000000008001274:	4c000020 	jirl	$r0,$r1,0
    panic("kvmpa");
9000000008001278:	1c000044 	pcaddu12i	$r4,2(0x2)
900000000800127c:	02fc4084 	addi.d	$r4,$r4,-240(0xf10)
9000000008001280:	57ef83ff 	bl	-4224(0xfffef80) # 9000000008000200 <panic>
    panic("kvmpa");
9000000008001284:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008001288:	02fc1084 	addi.d	$r4,$r4,-252(0xf04)
900000000800128c:	57ef77ff 	bl	-4236(0xfffef74) # 9000000008000200 <panic>

9000000008001290 <kvmpa>:
uint64 kvmpa(uint64 va) { return kwalkaddr(kernel_pagetable, va); }
9000000008001290:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008001294:	29c02061 	st.d	$r1,$r3,8(0x8)
9000000008001298:	29c00076 	st.d	$r22,$r3,0
900000000800129c:	02c04076 	addi.d	$r22,$r3,16(0x10)
90000000080012a0:	00150085 	move	$r5,$r4
90000000080012a4:	1c0002ac 	pcaddu12i	$r12,21(0x15)
90000000080012a8:	02fe318c 	addi.d	$r12,$r12,-116(0xf8c)
90000000080012ac:	28c00184 	ld.d	$r4,$r12,0
90000000080012b0:	57ff77ff 	bl	-140(0xfffff74) # 9000000008001224 <kwalkaddr>
90000000080012b4:	28c02061 	ld.d	$r1,$r3,8(0x8)
90000000080012b8:	28c00076 	ld.d	$r22,$r3,0
90000000080012bc:	02c04063 	addi.d	$r3,$r3,16(0x10)
90000000080012c0:	4c000020 	jirl	$r0,$r1,0

90000000080012c4 <mappages>:
// Create PTEs for virtual addresses starting at va that refer to
// physical addresses starting at pa. va and size might not
// be page-aligned. Returns 0 on success, -1 if walk() couldn't
// allocate a needed page-table page.
int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa,
             int perm) {
90000000080012c4:	02fec063 	addi.d	$r3,$r3,-80(0xfb0)
90000000080012c8:	29c12061 	st.d	$r1,$r3,72(0x48)
90000000080012cc:	29c10076 	st.d	$r22,$r3,64(0x40)
90000000080012d0:	29c0e077 	st.d	$r23,$r3,56(0x38)
90000000080012d4:	29c0c078 	st.d	$r24,$r3,48(0x30)
90000000080012d8:	29c0a079 	st.d	$r25,$r3,40(0x28)
90000000080012dc:	29c0807a 	st.d	$r26,$r3,32(0x20)
90000000080012e0:	29c0607b 	st.d	$r27,$r3,24(0x18)
90000000080012e4:	29c0407c 	st.d	$r28,$r3,16(0x10)
90000000080012e8:	29c0207d 	st.d	$r29,$r3,8(0x8)
90000000080012ec:	02c14076 	addi.d	$r22,$r3,80(0x50)
90000000080012f0:	0015009b 	move	$r27,$r4
90000000080012f4:	0015011c 	move	$r28,$r8
  // for visionfive 2
  // perm |= PTE_A | PTE_D;
  uint64 a, last;
  pte_t *pte;

  a = PGROUNDDOWN(va);
90000000080012f8:	15fffff9 	lu12i.w	$r25,-1(0xfffff)
90000000080012fc:	0014e4ba 	and	$r26,$r5,$r25
  last = PGROUNDDOWN(va + size - 1);
9000000008001300:	02fffcc6 	addi.d	$r6,$r6,-1(0xfff)
9000000008001304:	001094c6 	add.d	$r6,$r6,$r5
9000000008001308:	0014e4d9 	and	$r25,$r6,$r25
  a = PGROUNDDOWN(va);
900000000800130c:	00150358 	move	$r24,$r26
9000000008001310:	0011e8fa 	sub.d	$r26,$r7,$r26
    }

    *pte = PA2PTE(pa) | perm | PTE_V;
    if (a == last)
      break;
    a += PGSIZE;
9000000008001314:	1400003d 	lu12i.w	$r29,1(0x1)
9000000008001318:	50003000 	b	48(0x30) # 9000000008001348 <mappages+0x84>
      printf("mappages:%p %p\n", a, PTE2PA(*pte));
900000000800131c:	15ffffe6 	lu12i.w	$r6,-1(0xfffff)
9000000008001320:	161fffe6 	lu32i.d	$r6,65535(0xffff)
9000000008001324:	00149986 	and	$r6,$r12,$r6
9000000008001328:	00150305 	move	$r5,$r24
900000000800132c:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008001330:	02f99084 	addi.d	$r4,$r4,-412(0xe64)
9000000008001334:	57ef3fff 	bl	-4292(0xfffef3c) # 9000000008000270 <printf>
      panic("remap");
9000000008001338:	1c000044 	pcaddu12i	$r4,2(0x2)
900000000800133c:	02f9a084 	addi.d	$r4,$r4,-408(0xe68)
9000000008001340:	57eec3ff 	bl	-4416(0xfffeec0) # 9000000008000200 <panic>
    a += PGSIZE;
9000000008001344:	0010f718 	add.d	$r24,$r24,$r29
    pa += PGSIZE;
9000000008001348:	0010e357 	add.d	$r23,$r26,$r24
    if ((pte = walk(pagetable, a, 1)) == NULL)
900000000800134c:	02800406 	addi.w	$r6,$r0,1(0x1)
9000000008001350:	00150305 	move	$r5,$r24
9000000008001354:	00150364 	move	$r4,$r27
9000000008001358:	57fd1fff 	bl	-740(0xffffd1c) # 9000000008001074 <walk>
900000000800135c:	40003480 	beqz	$r4,52(0x34) # 9000000008001390 <mappages+0xcc>
    if (*pte & PTE_V) {
9000000008001360:	28c0008c 	ld.d	$r12,$r4,0
9000000008001364:	0340058d 	andi	$r13,$r12,0x1
9000000008001368:	47ffb5bf 	bnez	$r13,-76(0x7fffb4) # 900000000800131c <mappages+0x58>
    *pte = PA2PTE(pa) | perm | PTE_V;
900000000800136c:	15ffffec 	lu12i.w	$r12,-1(0xfffff)
9000000008001370:	161fffec 	lu32i.d	$r12,65535(0xffff)
9000000008001374:	0014b2f7 	and	$r23,$r23,$r12
9000000008001378:	001572f7 	or	$r23,$r23,$r28
900000000800137c:	038006f7 	ori	$r23,$r23,0x1
9000000008001380:	29c00097 	st.d	$r23,$r4,0
    if (a == last)
9000000008001384:	5fffc319 	bne	$r24,$r25,-64(0x3ffc0) # 9000000008001344 <mappages+0x80>
  }
  return 0;
9000000008001388:	00150004 	move	$r4,$r0
900000000800138c:	50000800 	b	8(0x8) # 9000000008001394 <mappages+0xd0>
      return -1;
9000000008001390:	02bffc04 	addi.w	$r4,$r0,-1(0xfff)
}
9000000008001394:	28c12061 	ld.d	$r1,$r3,72(0x48)
9000000008001398:	28c10076 	ld.d	$r22,$r3,64(0x40)
900000000800139c:	28c0e077 	ld.d	$r23,$r3,56(0x38)
90000000080013a0:	28c0c078 	ld.d	$r24,$r3,48(0x30)
90000000080013a4:	28c0a079 	ld.d	$r25,$r3,40(0x28)
90000000080013a8:	28c0807a 	ld.d	$r26,$r3,32(0x20)
90000000080013ac:	28c0607b 	ld.d	$r27,$r3,24(0x18)
90000000080013b0:	28c0407c 	ld.d	$r28,$r3,16(0x10)
90000000080013b4:	28c0207d 	ld.d	$r29,$r3,8(0x8)
90000000080013b8:	02c14063 	addi.d	$r3,$r3,80(0x50)
90000000080013bc:	4c000020 	jirl	$r0,$r1,0

90000000080013c0 <kvmmap>:
void kvmmap(uint64 va, uint64 pa, uint64 sz, int perm) {
90000000080013c0:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
90000000080013c4:	29c02061 	st.d	$r1,$r3,8(0x8)
90000000080013c8:	29c00076 	st.d	$r22,$r3,0
90000000080013cc:	02c04076 	addi.d	$r22,$r3,16(0x10)
  if (mappages(kernel_pagetable, va, sz, pa, perm) != 0)
90000000080013d0:	001500e8 	move	$r8,$r7
90000000080013d4:	001500a7 	move	$r7,$r5
90000000080013d8:	00150085 	move	$r5,$r4
90000000080013dc:	1c0002ac 	pcaddu12i	$r12,21(0x15)
90000000080013e0:	02f9518c 	addi.d	$r12,$r12,-428(0xe54)
90000000080013e4:	28c00184 	ld.d	$r4,$r12,0
90000000080013e8:	57fedfff 	bl	-292(0xffffedc) # 90000000080012c4 <mappages>
90000000080013ec:	44001480 	bnez	$r4,20(0x14) # 9000000008001400 <kvmmap+0x40>
} 
90000000080013f0:	28c02061 	ld.d	$r1,$r3,8(0x8)
90000000080013f4:	28c00076 	ld.d	$r22,$r3,0
90000000080013f8:	02c04063 	addi.d	$r3,$r3,16(0x10)
90000000080013fc:	4c000020 	jirl	$r0,$r1,0
    panic("kvmmap");
9000000008001400:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008001404:	02f6a084 	addi.d	$r4,$r4,-600(0xda8)
9000000008001408:	57edfbff 	bl	-4616(0xfffedf8) # 9000000008000200 <panic>

900000000800140c <kvminit>:
void kvminit() {
900000000800140c:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008001410:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008001414:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008001418:	29c02077 	st.d	$r23,$r3,8(0x8)
900000000800141c:	02c08076 	addi.d	$r22,$r3,32(0x20)
  kernel_pagetable = (pagetable_t)kalloc();
9000000008001420:	57fb47ff 	bl	-1212(0xffffb44) # 9000000008000f64 <kalloc>
9000000008001424:	1c0002ac 	pcaddu12i	$r12,21(0x15)
9000000008001428:	02f8318c 	addi.d	$r12,$r12,-500(0xe0c)
900000000800142c:	29c00184 	st.d	$r4,$r12,0
  memset(kernel_pagetable, 0, PGSIZE);
9000000008001430:	14000026 	lu12i.w	$r6,1(0x1)
9000000008001434:	00150005 	move	$r5,$r0
9000000008001438:	57f3dbff 	bl	-3112(0xffff3d8) # 9000000008000810 <memset>
  kvmmap(RAMBASE, RAMBASE, (uint64)etext - RAMBASE,
900000000800143c:	1c000097 	pcaddu12i	$r23,4(0x4)
9000000008001440:	28ef72f7 	ld.d	$r23,$r23,-1060(0xbdc)
9000000008001444:	14e00006 	lu12i.w	$r6,458752(0x70000)
9000000008001448:	17ffffe6 	lu32i.d	$r6,-1(0xfffff)
900000000800144c:	031bfcc6 	lu52i.d	$r6,$r6,1791(0x6ff)
9000000008001450:	02867007 	addi.w	$r7,$r0,412(0x19c)
9000000008001454:	00109ae6 	add.d	$r6,$r23,$r6
9000000008001458:	15200004 	lu12i.w	$r4,-458752(0x90000)
900000000800145c:	16000004 	lu32i.d	$r4,0
9000000008001460:	03240084 	lu52i.d	$r4,$r4,-1792(0x900)
9000000008001464:	00150085 	move	$r5,$r4
9000000008001468:	57ff5bff 	bl	-168(0xfffff58) # 90000000080013c0 <kvmmap>
  kvmmap((uint64)etext, (uint64)etext, RAMSTOP - (uint64)etext,
900000000800146c:	15300006 	lu12i.w	$r6,-425984(0x98000)
9000000008001470:	16000006 	lu32i.d	$r6,0
9000000008001474:	032400c6 	lu52i.d	$r6,$r6,-1792(0x900)
9000000008001478:	02867007 	addi.w	$r7,$r0,412(0x19c)
900000000800147c:	0011dcc6 	sub.d	$r6,$r6,$r23
9000000008001480:	001502e5 	move	$r5,$r23
9000000008001484:	001502e4 	move	$r4,$r23
9000000008001488:	57ff3bff 	bl	-200(0xfffff38) # 90000000080013c0 <kvmmap>
  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_W | PTE_MAT | PTE_PLV | PTE_P);
900000000800148c:	02867007 	addi.w	$r7,$r0,412(0x19c)
9000000008001490:	14000026 	lu12i.w	$r6,1(0x1)
9000000008001494:	1c000085 	pcaddu12i	$r5,4(0x4)
9000000008001498:	28edd0a5 	ld.d	$r5,$r5,-1164(0xb74)
900000000800149c:	14001fe4 	lu12i.w	$r4,255(0xff)
90000000080014a0:	57ff23ff 	bl	-224(0xfffff20) # 90000000080013c0 <kvmmap>
}
90000000080014a4:	28c06061 	ld.d	$r1,$r3,24(0x18)
90000000080014a8:	28c04076 	ld.d	$r22,$r3,16(0x10)
90000000080014ac:	28c02077 	ld.d	$r23,$r3,8(0x8)
90000000080014b0:	02c08063 	addi.d	$r3,$r3,32(0x20)
90000000080014b4:	4c000020 	jirl	$r0,$r1,0

90000000080014b8 <vmunmap>:

// Remove npages of mappings starting from va. va must be
// page-aligned. The mappings must exist.
// Optionally free the physical memory.
void vmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) {
90000000080014b8:	02fec063 	addi.d	$r3,$r3,-80(0xfb0)
90000000080014bc:	29c12061 	st.d	$r1,$r3,72(0x48)
90000000080014c0:	29c10076 	st.d	$r22,$r3,64(0x40)
90000000080014c4:	29c0e077 	st.d	$r23,$r3,56(0x38)
90000000080014c8:	29c0c078 	st.d	$r24,$r3,48(0x30)
90000000080014cc:	29c0a079 	st.d	$r25,$r3,40(0x28)
90000000080014d0:	29c0807a 	st.d	$r26,$r3,32(0x20)
90000000080014d4:	29c0607b 	st.d	$r27,$r3,24(0x18)
90000000080014d8:	29c0407c 	st.d	$r28,$r3,16(0x10)
90000000080014dc:	29c0207d 	st.d	$r29,$r3,8(0x8)
90000000080014e0:	29c0007e 	st.d	$r30,$r3,0
90000000080014e4:	02c14076 	addi.d	$r22,$r3,80(0x50)
  uint64 a;
  pte_t *pte;

  if ((va % PGSIZE) != 0)
90000000080014e8:	037ffcac 	andi	$r12,$r5,0xfff
90000000080014ec:	44005980 	bnez	$r12,88(0x58) # 9000000008001544 <vmunmap+0x8c>
90000000080014f0:	0015009a 	move	$r26,$r4
90000000080014f4:	001500b7 	move	$r23,$r5
90000000080014f8:	001500fd 	move	$r29,$r7
    panic("vmunmap: not aligned");

  for (a = va; a < va + npages * PGSIZE; a += PGSIZE) {
90000000080014fc:	004130c6 	slli.d	$r6,$r6,0xc
9000000008001500:	001094d9 	add.d	$r25,$r6,$r5
    if ((pte = walk(pagetable, a, 0)) == 0)
      panic("vmunmap: walk");
    if ((*pte & PTE_V) == 0)
      panic("vmunmap: not mapped");
    if (PTE_FLAGS(*pte) == PTE_V)
9000000008001504:	0280041c 	addi.w	$r28,$r0,1(0x1)
      panic("vmunmap: not a leaf");
    if (do_free) {
      uint64 pa = PTE2PA(*pte);
      kfree((void*)(pa | DMWIN_MASK));
9000000008001508:	0324001e 	lu52i.d	$r30,$r0,-1792(0x900)
  for (a = va; a < va + npages * PGSIZE; a += PGSIZE) {
900000000800150c:	1400003b 	lu12i.w	$r27,1(0x1)
9000000008001510:	680084b9 	bltu	$r5,$r25,132(0x84) # 9000000008001594 <vmunmap+0xdc>
    }
    *pte = 0;
  }
}
9000000008001514:	28c12061 	ld.d	$r1,$r3,72(0x48)
9000000008001518:	28c10076 	ld.d	$r22,$r3,64(0x40)
900000000800151c:	28c0e077 	ld.d	$r23,$r3,56(0x38)
9000000008001520:	28c0c078 	ld.d	$r24,$r3,48(0x30)
9000000008001524:	28c0a079 	ld.d	$r25,$r3,40(0x28)
9000000008001528:	28c0807a 	ld.d	$r26,$r3,32(0x20)
900000000800152c:	28c0607b 	ld.d	$r27,$r3,24(0x18)
9000000008001530:	28c0407c 	ld.d	$r28,$r3,16(0x10)
9000000008001534:	28c0207d 	ld.d	$r29,$r3,8(0x8)
9000000008001538:	28c0007e 	ld.d	$r30,$r3,0
900000000800153c:	02c14063 	addi.d	$r3,$r3,80(0x50)
9000000008001540:	4c000020 	jirl	$r0,$r1,0
    panic("vmunmap: not aligned");
9000000008001544:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008001548:	02f1b084 	addi.d	$r4,$r4,-916(0xc6c)
900000000800154c:	57ecb7ff 	bl	-4940(0xfffecb4) # 9000000008000200 <panic>
      panic("vmunmap: walk");
9000000008001550:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008001554:	02f1e084 	addi.d	$r4,$r4,-904(0xc78)
9000000008001558:	57ecabff 	bl	-4952(0xfffeca8) # 9000000008000200 <panic>
      panic("vmunmap: not mapped");
900000000800155c:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008001560:	02f1f084 	addi.d	$r4,$r4,-900(0xc7c)
9000000008001564:	57ec9fff 	bl	-4964(0xfffec9c) # 9000000008000200 <panic>
      panic("vmunmap: not a leaf");
9000000008001568:	1c000044 	pcaddu12i	$r4,2(0x2)
900000000800156c:	02f22084 	addi.d	$r4,$r4,-888(0xc88)
9000000008001570:	57ec93ff 	bl	-4976(0xfffec90) # 9000000008000200 <panic>
      uint64 pa = PTE2PA(*pte);
9000000008001574:	15ffffec 	lu12i.w	$r12,-1(0xfffff)
9000000008001578:	161fffec 	lu32i.d	$r12,65535(0xffff)
900000000800157c:	0014b084 	and	$r4,$r4,$r12
      kfree((void*)(pa | DMWIN_MASK));
9000000008001580:	00157884 	or	$r4,$r4,$r30
9000000008001584:	57f853ff 	bl	-1968(0xffff850) # 9000000008000dd4 <kfree>
    *pte = 0;
9000000008001588:	29c00300 	st.d	$r0,$r24,0
  for (a = va; a < va + npages * PGSIZE; a += PGSIZE) {
900000000800158c:	0010eef7 	add.d	$r23,$r23,$r27
9000000008001590:	6fff86f9 	bgeu	$r23,$r25,-124(0x3ff84) # 9000000008001514 <vmunmap+0x5c>
    if ((pte = walk(pagetable, a, 0)) == 0)
9000000008001594:	00150006 	move	$r6,$r0
9000000008001598:	001502e5 	move	$r5,$r23
900000000800159c:	00150344 	move	$r4,$r26
90000000080015a0:	57fad7ff 	bl	-1324(0xffffad4) # 9000000008001074 <walk>
90000000080015a4:	00150098 	move	$r24,$r4
90000000080015a8:	43ffa89f 	beqz	$r4,-88(0x7fffa8) # 9000000008001550 <vmunmap+0x98>
    if ((*pte & PTE_V) == 0)
90000000080015ac:	28c00084 	ld.d	$r4,$r4,0
90000000080015b0:	0340048c 	andi	$r12,$r4,0x1
90000000080015b4:	43ffa99f 	beqz	$r12,-88(0x7fffa8) # 900000000800155c <vmunmap+0xa4>
    if (PTE_FLAGS(*pte) == PTE_V)
90000000080015b8:	0287fc0c 	addi.w	$r12,$r0,511(0x1ff)
90000000080015bc:	0338018c 	lu52i.d	$r12,$r12,-512(0xe00)
90000000080015c0:	0014b08c 	and	$r12,$r4,$r12
90000000080015c4:	5bffa59c 	beq	$r12,$r28,-92(0x3ffa4) # 9000000008001568 <vmunmap+0xb0>
    if (do_free) {
90000000080015c8:	43ffc3bf 	beqz	$r29,-64(0x7fffc0) # 9000000008001588 <vmunmap+0xd0>
90000000080015cc:	53ffabff 	b	-88(0xfffffa8) # 9000000008001574 <vmunmap+0xbc>

90000000080015d0 <uvmcreate>:

// create an empty user page table.
// returns 0 if out of memory.
pagetable_t uvmcreate() {
90000000080015d0:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
90000000080015d4:	29c06061 	st.d	$r1,$r3,24(0x18)
90000000080015d8:	29c04076 	st.d	$r22,$r3,16(0x10)
90000000080015dc:	29c02077 	st.d	$r23,$r3,8(0x8)
90000000080015e0:	02c08076 	addi.d	$r22,$r3,32(0x20)
  pagetable_t pagetable;
  pagetable = (pagetable_t)kalloc();
90000000080015e4:	57f983ff 	bl	-1664(0xffff980) # 9000000008000f64 <kalloc>
90000000080015e8:	00150097 	move	$r23,$r4
  if (pagetable == NULL)
90000000080015ec:	40001080 	beqz	$r4,16(0x10) # 90000000080015fc <uvmcreate+0x2c>
    return NULL;
  memset(pagetable, 0, PGSIZE);
90000000080015f0:	14000026 	lu12i.w	$r6,1(0x1)
90000000080015f4:	00150005 	move	$r5,$r0
90000000080015f8:	57f21bff 	bl	-3560(0xffff218) # 9000000008000810 <memset>
  return pagetable;
}
90000000080015fc:	001502e4 	move	$r4,$r23
9000000008001600:	28c06061 	ld.d	$r1,$r3,24(0x18)
9000000008001604:	28c04076 	ld.d	$r22,$r3,16(0x10)
9000000008001608:	28c02077 	ld.d	$r23,$r3,8(0x8)
900000000800160c:	02c08063 	addi.d	$r3,$r3,32(0x20)
9000000008001610:	4c000020 	jirl	$r0,$r1,0

9000000008001614 <uvminit>:

// Load the user initcode into address 0 of pagetable,
// for the very first process.
// sz must be less than a page.
void uvminit(pagetable_t pagetable, pagetable_t kpagetable, uchar *src,
             uint sz) {
9000000008001614:	02fec063 	addi.d	$r3,$r3,-80(0xfb0)
9000000008001618:	29c12061 	st.d	$r1,$r3,72(0x48)
900000000800161c:	29c10076 	st.d	$r22,$r3,64(0x40)
9000000008001620:	29c0e077 	st.d	$r23,$r3,56(0x38)
9000000008001624:	29c0c078 	st.d	$r24,$r3,48(0x30)
9000000008001628:	29c0a079 	st.d	$r25,$r3,40(0x28)
900000000800162c:	29c0807a 	st.d	$r26,$r3,32(0x20)
9000000008001630:	29c0607b 	st.d	$r27,$r3,24(0x18)
9000000008001634:	29c0407c 	st.d	$r28,$r3,16(0x10)
9000000008001638:	29c0207d 	st.d	$r29,$r3,8(0x8)
900000000800163c:	29c0007e 	st.d	$r30,$r3,0
9000000008001640:	02c14076 	addi.d	$r22,$r3,80(0x50)
9000000008001644:	0015009c 	move	$r28,$r4
9000000008001648:	001500bb 	move	$r27,$r5
900000000800164c:	001500da 	move	$r26,$r6
9000000008001650:	001500fe 	move	$r30,$r7
  char *mem;
  uint64 i;
  for (i = 0; i + PGSIZE < sz; i += PGSIZE) {
9000000008001654:	00df00f9 	bstrpick.d	$r25,$r7,0x1f,0x0
9000000008001658:	1400002c 	lu12i.w	$r12,1(0x1)
900000000800165c:	0015001d 	move	$r29,$r0
9000000008001660:	6c008d99 	bgeu	$r12,$r25,140(0x8c) # 90000000080016ec <uvminit+0xd8>
9000000008001664:	15ffffcc 	lu12i.w	$r12,-2(0xffffe)
9000000008001668:	03bffd8c 	ori	$r12,$r12,0xfff
900000000800166c:	0010b339 	add.d	$r25,$r25,$r12
9000000008001670:	15ffffec 	lu12i.w	$r12,-1(0xfffff)
9000000008001674:	0014b339 	and	$r25,$r25,$r12
9000000008001678:	1400003d 	lu12i.w	$r29,1(0x1)
900000000800167c:	0010f73d 	add.d	$r29,$r25,$r29
9000000008001680:	00150017 	move	$r23,$r0
9000000008001684:	50000800 	b	8(0x8) # 900000000800168c <uvminit+0x78>
9000000008001688:	00150197 	move	$r23,$r12
    mem = kalloc();
900000000800168c:	57f8dbff 	bl	-1832(0xffff8d8) # 9000000008000f64 <kalloc>
9000000008001690:	00150098 	move	$r24,$r4
    // printf("[uvminit]kalloc: %p\n", mem);
    memset(mem, 0, PGSIZE);
9000000008001694:	14000026 	lu12i.w	$r6,1(0x1)
9000000008001698:	00150005 	move	$r5,$r0
900000000800169c:	57f177ff 	bl	-3724(0xffff174) # 9000000008000810 <memset>
    mappages(pagetable, i, PGSIZE, (uint64)mem, PTE_P | PTE_PLV | PTE_W | PTE_MAT);
90000000080016a0:	02867008 	addi.w	$r8,$r0,412(0x19c)
90000000080016a4:	00150307 	move	$r7,$r24
90000000080016a8:	14000026 	lu12i.w	$r6,1(0x1)
90000000080016ac:	001502e5 	move	$r5,$r23
90000000080016b0:	00150384 	move	$r4,$r28
90000000080016b4:	57fc13ff 	bl	-1008(0xffffc10) # 90000000080012c4 <mappages>
    mappages(kpagetable, i, PGSIZE, (uint64)mem, PTE_W | PTE_P | PTE_MAT);
90000000080016b8:	02864008 	addi.w	$r8,$r0,400(0x190)
90000000080016bc:	00150307 	move	$r7,$r24
90000000080016c0:	14000026 	lu12i.w	$r6,1(0x1)
90000000080016c4:	001502e5 	move	$r5,$r23
90000000080016c8:	00150364 	move	$r4,$r27
90000000080016cc:	57fbfbff 	bl	-1032(0xffffbf8) # 90000000080012c4 <mappages>
    memmove(mem, src + i, PGSIZE);
90000000080016d0:	14000026 	lu12i.w	$r6,1(0x1)
90000000080016d4:	0010df45 	add.d	$r5,$r26,$r23
90000000080016d8:	00150304 	move	$r4,$r24
90000000080016dc:	57f1dfff 	bl	-3620(0xffff1dc) # 90000000080008b8 <memmove>
90000000080016e0:	1400002c 	lu12i.w	$r12,1(0x1)
90000000080016e4:	0010b2ec 	add.d	$r12,$r23,$r12
  for (i = 0; i + PGSIZE < sz; i += PGSIZE) {
90000000080016e8:	5fffa2f9 	bne	$r23,$r25,-96(0x3ffa0) # 9000000008001688 <uvminit+0x74>
  }
  mem = kalloc();
90000000080016ec:	57f87bff 	bl	-1928(0xffff878) # 9000000008000f64 <kalloc>
90000000080016f0:	00150097 	move	$r23,$r4
  memset(mem, 0, PGSIZE);
90000000080016f4:	14000026 	lu12i.w	$r6,1(0x1)
90000000080016f8:	00150005 	move	$r5,$r0
90000000080016fc:	57f117ff 	bl	-3820(0xffff114) # 9000000008000810 <memset>
  mappages(pagetable, i, PGSIZE, (uint64)mem, PTE_P | PTE_PLV | PTE_W | PTE_MAT);
9000000008001700:	02867008 	addi.w	$r8,$r0,412(0x19c)
9000000008001704:	001502e7 	move	$r7,$r23
9000000008001708:	14000026 	lu12i.w	$r6,1(0x1)
900000000800170c:	001503a5 	move	$r5,$r29
9000000008001710:	00150384 	move	$r4,$r28
9000000008001714:	57fbb3ff 	bl	-1104(0xffffbb0) # 90000000080012c4 <mappages>
  mappages(kpagetable, i, PGSIZE, (uint64)mem, PTE_P | PTE_W | PTE_MAT);
9000000008001718:	02864008 	addi.w	$r8,$r0,400(0x190)
900000000800171c:	001502e7 	move	$r7,$r23
9000000008001720:	14000026 	lu12i.w	$r6,1(0x1)
9000000008001724:	001503a5 	move	$r5,$r29
9000000008001728:	00150364 	move	$r4,$r27
900000000800172c:	57fb9bff 	bl	-1128(0xffffb98) # 90000000080012c4 <mappages>
  memmove(mem, src + i, sz % PGSIZE);
9000000008001730:	037fffc6 	andi	$r6,$r30,0xfff
9000000008001734:	0010f745 	add.d	$r5,$r26,$r29
9000000008001738:	001502e4 	move	$r4,$r23
900000000800173c:	57f17fff 	bl	-3716(0xffff17c) # 90000000080008b8 <memmove>
  printf("uvminit done sz:%d\n", sz);
9000000008001740:	001503c5 	move	$r5,$r30
9000000008001744:	1c000044 	pcaddu12i	$r4,2(0x2)
9000000008001748:	02eb1084 	addi.d	$r4,$r4,-1340(0xac4)
900000000800174c:	57eb27ff 	bl	-5340(0xfffeb24) # 9000000008000270 <printf>
  // for (int i = 0; i < sz; i ++) {
  //   printf("[uvminit]mem: %p, %x\n", mem + i, mem[i]);
  // }
}
9000000008001750:	28c12061 	ld.d	$r1,$r3,72(0x48)
9000000008001754:	28c10076 	ld.d	$r22,$r3,64(0x40)
9000000008001758:	28c0e077 	ld.d	$r23,$r3,56(0x38)
900000000800175c:	28c0c078 	ld.d	$r24,$r3,48(0x30)
9000000008001760:	28c0a079 	ld.d	$r25,$r3,40(0x28)
9000000008001764:	28c0807a 	ld.d	$r26,$r3,32(0x20)
9000000008001768:	28c0607b 	ld.d	$r27,$r3,24(0x18)
900000000800176c:	28c0407c 	ld.d	$r28,$r3,16(0x10)
9000000008001770:	28c0207d 	ld.d	$r29,$r3,8(0x8)
9000000008001774:	28c0007e 	ld.d	$r30,$r3,0
9000000008001778:	02c14063 	addi.d	$r3,$r3,80(0x50)
900000000800177c:	4c000020 	jirl	$r0,$r1,0

9000000008001780 <uvmdealloc>:
// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
// need to be less than oldsz.  oldsz can be larger than the actual
// process size.  Returns the new process size.
// 释放虚拟空间大小
uint64 uvmdealloc(pagetable_t pagetable, pagetable_t kpagetable, uint64 oldsz,
                  uint64 newsz) {
9000000008001780:	02ff4063 	addi.d	$r3,$r3,-48(0xfd0)
9000000008001784:	29c0a061 	st.d	$r1,$r3,40(0x28)
9000000008001788:	29c08076 	st.d	$r22,$r3,32(0x20)
900000000800178c:	29c06077 	st.d	$r23,$r3,24(0x18)
9000000008001790:	29c04078 	st.d	$r24,$r3,16(0x10)
9000000008001794:	29c02079 	st.d	$r25,$r3,8(0x8)
9000000008001798:	29c0007a 	st.d	$r26,$r3,0
900000000800179c:	02c0c076 	addi.d	$r22,$r3,48(0x30)
  if (newsz >= oldsz)
    return oldsz;
90000000080017a0:	001500d8 	move	$r24,$r6
  if (newsz >= oldsz)
90000000080017a4:	6c002ce6 	bgeu	$r7,$r6,44(0x2c) # 90000000080017d0 <uvmdealloc+0x50>
90000000080017a8:	0015009a 	move	$r26,$r4
90000000080017ac:	001500a4 	move	$r4,$r5
90000000080017b0:	001500f8 	move	$r24,$r7

  if (PGROUNDUP(newsz) < PGROUNDUP(oldsz)) {
90000000080017b4:	03bffc0d 	ori	$r13,$r0,0xfff
90000000080017b8:	0010b4f9 	add.d	$r25,$r7,$r13
90000000080017bc:	15ffffec 	lu12i.w	$r12,-1(0xfffff)
90000000080017c0:	0014b339 	and	$r25,$r25,$r12
90000000080017c4:	0010b4c6 	add.d	$r6,$r6,$r13
90000000080017c8:	0014b0c6 	and	$r6,$r6,$r12
90000000080017cc:	68002b26 	bltu	$r25,$r6,40(0x28) # 90000000080017f4 <uvmdealloc+0x74>
    vmunmap(kpagetable, PGROUNDUP(newsz), npages, 0);
    vmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
  }

  return newsz;
}
90000000080017d0:	00150304 	move	$r4,$r24
90000000080017d4:	28c0a061 	ld.d	$r1,$r3,40(0x28)
90000000080017d8:	28c08076 	ld.d	$r22,$r3,32(0x20)
90000000080017dc:	28c06077 	ld.d	$r23,$r3,24(0x18)
90000000080017e0:	28c04078 	ld.d	$r24,$r3,16(0x10)
90000000080017e4:	28c02079 	ld.d	$r25,$r3,8(0x8)
90000000080017e8:	28c0007a 	ld.d	$r26,$r3,0
90000000080017ec:	02c0c063 	addi.d	$r3,$r3,48(0x30)
90000000080017f0:	4c000020 	jirl	$r0,$r1,0
    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
90000000080017f4:	0011e4d7 	sub.d	$r23,$r6,$r25
90000000080017f8:	004532f7 	srli.d	$r23,$r23,0xc
90000000080017fc:	004082f7 	slli.w	$r23,$r23,0x0
    vmunmap(kpagetable, PGROUNDUP(newsz), npages, 0);
9000000008001800:	00150007 	move	$r7,$r0
9000000008001804:	001502e6 	move	$r6,$r23
9000000008001808:	00150325 	move	$r5,$r25
900000000800180c:	57fcafff 	bl	-852(0xffffcac) # 90000000080014b8 <vmunmap>
    vmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
9000000008001810:	02800407 	addi.w	$r7,$r0,1(0x1)
9000000008001814:	001502e6 	move	$r6,$r23
9000000008001818:	00150325 	move	$r5,$r25
900000000800181c:	00150344 	move	$r4,$r26
9000000008001820:	57fc9bff 	bl	-872(0xffffc98) # 90000000080014b8 <vmunmap>
9000000008001824:	53ffafff 	b	-84(0xfffffac) # 90000000080017d0 <uvmdealloc+0x50>

9000000008001828 <uvmalloc>:
  if (newsz < oldsz)
9000000008001828:	68016ce6 	bltu	$r7,$r6,364(0x16c) # 9000000008001994 <uvmalloc+0x16c>
                uint64 newsz, int perm) {
900000000800182c:	02fec063 	addi.d	$r3,$r3,-80(0xfb0)
9000000008001830:	29c12061 	st.d	$r1,$r3,72(0x48)
9000000008001834:	29c10076 	st.d	$r22,$r3,64(0x40)
9000000008001838:	29c0e077 	st.d	$r23,$r3,56(0x38)
900000000800183c:	29c0c078 	st.d	$r24,$r3,48(0x30)
9000000008001840:	29c0a079 	st.d	$r25,$r3,40(0x28)
9000000008001844:	29c0807a 	st.d	$r26,$r3,32(0x20)
9000000008001848:	29c0607b 	st.d	$r27,$r3,24(0x18)
900000000800184c:	29c0407c 	st.d	$r28,$r3,16(0x10)
9000000008001850:	29c0207d 	st.d	$r29,$r3,8(0x8)
9000000008001854:	29c0007e 	st.d	$r30,$r3,0
9000000008001858:	02c14076 	addi.d	$r22,$r3,80(0x50)
  oldsz = PGROUNDUP(oldsz);
900000000800185c:	03bffc19 	ori	$r25,$r0,0xfff
9000000008001860:	0010e4c6 	add.d	$r6,$r6,$r25
9000000008001864:	15fffff9 	lu12i.w	$r25,-1(0xfffff)
9000000008001868:	0014e4d9 	and	$r25,$r6,$r25
  for (a = oldsz; a < newsz; a += PGSIZE) {
900000000800186c:	6c013327 	bgeu	$r25,$r7,304(0x130) # 900000000800199c <uvmalloc+0x174>
9000000008001870:	0015011d 	move	$r29,$r8
9000000008001874:	001500fc 	move	$r28,$r7
9000000008001878:	001500bb 	move	$r27,$r5
900000000800187c:	0015009a 	move	$r26,$r4
9000000008001880:	00150337 	move	$r23,$r25
    if (mappages(pagetable, a, PGSIZE, (uint64)mem, perm | PTE_PLV) != 0) {
9000000008001884:	0380311e 	ori	$r30,$r8,0xc
    mem = kalloc();
9000000008001888:	57f6dfff 	bl	-2340(0xffff6dc) # 9000000008000f64 <kalloc>
900000000800188c:	00150098 	move	$r24,$r4
    if (mem == NULL) {
9000000008001890:	40005c80 	beqz	$r4,92(0x5c) # 90000000080018ec <uvmalloc+0xc4>
    memset(mem, 0, PGSIZE);
9000000008001894:	14000026 	lu12i.w	$r6,1(0x1)
9000000008001898:	00150005 	move	$r5,$r0
900000000800189c:	57ef77ff 	bl	-4236(0xfffef74) # 9000000008000810 <memset>
    if (mappages(pagetable, a, PGSIZE, (uint64)mem, perm | PTE_PLV) != 0) {
90000000080018a0:	001503c8 	move	$r8,$r30
90000000080018a4:	00150307 	move	$r7,$r24
90000000080018a8:	14000026 	lu12i.w	$r6,1(0x1)
90000000080018ac:	001502e5 	move	$r5,$r23
90000000080018b0:	00150344 	move	$r4,$r26
90000000080018b4:	57fa13ff 	bl	-1520(0xffffa10) # 90000000080012c4 <mappages>
90000000080018b8:	44007c80 	bnez	$r4,124(0x7c) # 9000000008001934 <uvmalloc+0x10c>
    if (mappages(kpagetable , a, PGSIZE, (uint64)mem, perm) != 0) {
90000000080018bc:	001503a8 	move	$r8,$r29
90000000080018c0:	00150307 	move	$r7,$r24
90000000080018c4:	14000026 	lu12i.w	$r6,1(0x1)
90000000080018c8:	001502e5 	move	$r5,$r23
90000000080018cc:	00150364 	move	$r4,$r27
90000000080018d0:	57f9f7ff 	bl	-1548(0xffff9f4) # 90000000080012c4 <mappages>
90000000080018d4:	44008480 	bnez	$r4,132(0x84) # 9000000008001958 <uvmalloc+0x130>
  for (a = oldsz; a < newsz; a += PGSIZE) {
90000000080018d8:	1400002c 	lu12i.w	$r12,1(0x1)
90000000080018dc:	0010b2f7 	add.d	$r23,$r23,$r12
90000000080018e0:	6bffaafc 	bltu	$r23,$r28,-88(0x3ffa8) # 9000000008001888 <uvmalloc+0x60>
  return newsz;
90000000080018e4:	00150384 	move	$r4,$r28
90000000080018e8:	50001c00 	b	28(0x1c) # 9000000008001904 <uvmalloc+0xdc>
      uvmdealloc(pagetable, kpagetable, a, oldsz);
90000000080018ec:	00150327 	move	$r7,$r25
90000000080018f0:	001502e6 	move	$r6,$r23
90000000080018f4:	00150365 	move	$r5,$r27
90000000080018f8:	00150344 	move	$r4,$r26
90000000080018fc:	57fe87ff 	bl	-380(0xffffe84) # 9000000008001780 <uvmdealloc>
      return 0;
9000000008001900:	00150004 	move	$r4,$r0
}
9000000008001904:	28c12061 	ld.d	$r1,$r3,72(0x48)
9000000008001908:	28c10076 	ld.d	$r22,$r3,64(0x40)
900000000800190c:	28c0e077 	ld.d	$r23,$r3,56(0x38)
9000000008001910:	28c0c078 	ld.d	$r24,$r3,48(0x30)
9000000008001914:	28c0a079 	ld.d	$r25,$r3,40(0x28)
9000000008001918:	28c0807a 	ld.d	$r26,$r3,32(0x20)
900000000800191c:	28c0607b 	ld.d	$r27,$r3,24(0x18)
9000000008001920:	28c0407c 	ld.d	$r28,$r3,16(0x10)
9000000008001924:	28c0207d 	ld.d	$r29,$r3,8(0x8)
9000000008001928:	28c0007e 	ld.d	$r30,$r3,0
900000000800192c:	02c14063 	addi.d	$r3,$r3,80(0x50)
9000000008001930:	4c000020 	jirl	$r0,$r1,0
      kfree(mem);
9000000008001934:	00150304 	move	$r4,$r24
9000000008001938:	57f49fff 	bl	-2916(0xffff49c) # 9000000008000dd4 <kfree>
      uvmdealloc(pagetable, kpagetable, a, oldsz);
900000000800193c:	00150327 	move	$r7,$r25
9000000008001940:	001502e6 	move	$r6,$r23
9000000008001944:	00150365 	move	$r5,$r27
9000000008001948:	00150344 	move	$r4,$r26
900000000800194c:	57fe37ff 	bl	-460(0xffffe34) # 9000000008001780 <uvmdealloc>
      return 0;
9000000008001950:	00150004 	move	$r4,$r0
9000000008001954:	53ffb3ff 	b	-80(0xfffffb0) # 9000000008001904 <uvmalloc+0xdc>
      int npages = (a - oldsz) / PGSIZE;
9000000008001958:	0011e6f7 	sub.d	$r23,$r23,$r25
900000000800195c:	004532f7 	srli.d	$r23,$r23,0xc
9000000008001960:	004082f7 	slli.w	$r23,$r23,0x0
      vmunmap(pagetable, oldsz, npages + 1,
9000000008001964:	02800407 	addi.w	$r7,$r0,1(0x1)
9000000008001968:	028006e6 	addi.w	$r6,$r23,1(0x1)
900000000800196c:	00150325 	move	$r5,$r25
9000000008001970:	00150344 	move	$r4,$r26
9000000008001974:	57fb47ff 	bl	-1212(0xffffb44) # 90000000080014b8 <vmunmap>
      vmunmap(kpagetable, oldsz, npages, 0);
9000000008001978:	00150007 	move	$r7,$r0
900000000800197c:	001502e6 	move	$r6,$r23
9000000008001980:	00150325 	move	$r5,$r25
9000000008001984:	00150364 	move	$r4,$r27
9000000008001988:	57fb33ff 	bl	-1232(0xffffb30) # 90000000080014b8 <vmunmap>
      return 0;
900000000800198c:	00150004 	move	$r4,$r0
9000000008001990:	53ff77ff 	b	-140(0xfffff74) # 9000000008001904 <uvmalloc+0xdc>
    return oldsz;
9000000008001994:	001500c4 	move	$r4,$r6
}
9000000008001998:	4c000020 	jirl	$r0,$r1,0
  return newsz;
900000000800199c:	001500e4 	move	$r4,$r7
90000000080019a0:	53ff67ff 	b	-156(0xfffff64) # 9000000008001904 <uvmalloc+0xdc>

90000000080019a4 <freewalk>:

// Recursively free page-table pages.
// All leaf mappings must already have been removed.
void freewalk(pagetable_t pagetable) {
90000000080019a4:	02ff0063 	addi.d	$r3,$r3,-64(0xfc0)
90000000080019a8:	29c0e061 	st.d	$r1,$r3,56(0x38)
90000000080019ac:	29c0c076 	st.d	$r22,$r3,48(0x30)
90000000080019b0:	29c0a077 	st.d	$r23,$r3,40(0x28)
90000000080019b4:	29c08078 	st.d	$r24,$r3,32(0x20)
90000000080019b8:	29c06079 	st.d	$r25,$r3,24(0x18)
90000000080019bc:	29c0407a 	st.d	$r26,$r3,16(0x10)
90000000080019c0:	29c0207b 	st.d	$r27,$r3,8(0x8)
90000000080019c4:	02c10076 	addi.d	$r22,$r3,64(0x40)
90000000080019c8:	0015009b 	move	$r27,$r4
  // there are 2^9 = 512 PTEs in a page table.
  for (int i = 0; i < 512; i++) {
90000000080019cc:	00150097 	move	$r23,$r4
90000000080019d0:	14000038 	lu12i.w	$r24,1(0x1)
90000000080019d4:	0010e098 	add.d	$r24,$r4,$r24
    pte_t pte = pagetable[i];
    if ((pte & PTE_V) && PTE_FLAGS(pte) == PTE_V ) {
90000000080019d8:	02800419 	addi.w	$r25,$r0,1(0x1)
      // this PTE points to a lower-level page table.
      uint64 child = (PTE2PA(pte) | DMWIN_MASK);
90000000080019dc:	0324001a 	lu52i.d	$r26,$r0,-1792(0x900)
90000000080019e0:	50002400 	b	36(0x24) # 9000000008001a04 <freewalk+0x60>
90000000080019e4:	15ffffec 	lu12i.w	$r12,-1(0xfffff)
90000000080019e8:	161fffec 	lu32i.d	$r12,65535(0xffff)
90000000080019ec:	0014b084 	and	$r4,$r4,$r12
      freewalk((pagetable_t)child);
90000000080019f0:	00156884 	or	$r4,$r4,$r26
90000000080019f4:	57ffb3ff 	bl	-80(0xfffffb0) # 90000000080019a4 <freewalk>
      pagetable[i] = 0;
90000000080019f8:	29c002e0 	st.d	$r0,$r23,0
90000000080019fc:	02c022f7 	addi.d	$r23,$r23,8(0x8)
  for (int i = 0; i < 512; i++) {
9000000008001a00:	58001ef8 	beq	$r23,$r24,28(0x1c) # 9000000008001a1c <freewalk+0x78>
    pte_t pte = pagetable[i];
9000000008001a04:	28c002e4 	ld.d	$r4,$r23,0
    if ((pte & PTE_V) && PTE_FLAGS(pte) == PTE_V ) {
9000000008001a08:	0287fc0c 	addi.w	$r12,$r0,511(0x1ff)
9000000008001a0c:	0338018c 	lu52i.d	$r12,$r12,-512(0xe00)
9000000008001a10:	0014b08c 	and	$r12,$r4,$r12
9000000008001a14:	5fffe999 	bne	$r12,$r25,-24(0x3ffe8) # 90000000080019fc <freewalk+0x58>
9000000008001a18:	53ffcfff 	b	-52(0xfffffcc) # 90000000080019e4 <freewalk+0x40>
    } else if (pte & PTE_V) {
      // panic("freewalk: leaf");
      continue;
    }
  }
  kfree((void *)pagetable);
9000000008001a1c:	00150364 	move	$r4,$r27
9000000008001a20:	57f3b7ff 	bl	-3148(0xffff3b4) # 9000000008000dd4 <kfree>
}
9000000008001a24:	28c0e061 	ld.d	$r1,$r3,56(0x38)
9000000008001a28:	28c0c076 	ld.d	$r22,$r3,48(0x30)
9000000008001a2c:	28c0a077 	ld.d	$r23,$r3,40(0x28)
9000000008001a30:	28c08078 	ld.d	$r24,$r3,32(0x20)
9000000008001a34:	28c06079 	ld.d	$r25,$r3,24(0x18)
9000000008001a38:	28c0407a 	ld.d	$r26,$r3,16(0x10)
9000000008001a3c:	28c0207b 	ld.d	$r27,$r3,8(0x8)
9000000008001a40:	02c10063 	addi.d	$r3,$r3,64(0x40)
9000000008001a44:	4c000020 	jirl	$r0,$r1,0

9000000008001a48 <uvmfree>:

// Free user memory pages,
// then free page-table pages.
// 用户内存和页表
void uvmfree(pagetable_t pagetable, uint64 sz) {
9000000008001a48:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008001a4c:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008001a50:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008001a54:	29c02077 	st.d	$r23,$r3,8(0x8)
9000000008001a58:	02c08076 	addi.d	$r22,$r3,32(0x20)
9000000008001a5c:	00150097 	move	$r23,$r4
  if (sz > 0)
9000000008001a60:	440020a0 	bnez	$r5,32(0x20) # 9000000008001a80 <uvmfree+0x38>
    vmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 1);
  freewalk(pagetable);
9000000008001a64:	001502e4 	move	$r4,$r23
9000000008001a68:	57ff3fff 	bl	-196(0xfffff3c) # 90000000080019a4 <freewalk>
}
9000000008001a6c:	28c06061 	ld.d	$r1,$r3,24(0x18)
9000000008001a70:	28c04076 	ld.d	$r22,$r3,16(0x10)
9000000008001a74:	28c02077 	ld.d	$r23,$r3,8(0x8)
9000000008001a78:	02c08063 	addi.d	$r3,$r3,32(0x20)
9000000008001a7c:	4c000020 	jirl	$r0,$r1,0
    vmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 1);
9000000008001a80:	03bffc06 	ori	$r6,$r0,0xfff
9000000008001a84:	001098a6 	add.d	$r6,$r5,$r6
9000000008001a88:	02800407 	addi.w	$r7,$r0,1(0x1)
9000000008001a8c:	004530c6 	srli.d	$r6,$r6,0xc
9000000008001a90:	00150005 	move	$r5,$r0
9000000008001a94:	57fa27ff 	bl	-1500(0xffffa24) # 90000000080014b8 <vmunmap>
9000000008001a98:	53ffcfff 	b	-52(0xfffffcc) # 9000000008001a64 <uvmfree+0x1c>

9000000008001a9c <uvmcopy>:
  pte_t *pte;
  uint64 pa, i = 0, ki = 0;
  uint flags;
  char *mem;

  while (i < sz) {
9000000008001a9c:	400178e0 	beqz	$r7,376(0x178) # 9000000008001c14 <uvmcopy+0x178>
int uvmcopy(pagetable_t old, pagetable_t new, pagetable_t knew, uint64 sz) {
9000000008001aa0:	02fe4063 	addi.d	$r3,$r3,-112(0xf90)
9000000008001aa4:	29c1a061 	st.d	$r1,$r3,104(0x68)
9000000008001aa8:	29c18076 	st.d	$r22,$r3,96(0x60)
9000000008001aac:	29c16077 	st.d	$r23,$r3,88(0x58)
9000000008001ab0:	29c14078 	st.d	$r24,$r3,80(0x50)
9000000008001ab4:	29c12079 	st.d	$r25,$r3,72(0x48)
9000000008001ab8:	29c1007a 	st.d	$r26,$r3,64(0x40)
9000000008001abc:	29c0e07b 	st.d	$r27,$r3,56(0x38)
9000000008001ac0:	29c0c07c 	st.d	$r28,$r3,48(0x30)
9000000008001ac4:	29c0a07d 	st.d	$r29,$r3,40(0x28)
9000000008001ac8:	29c0807e 	st.d	$r30,$r3,32(0x20)
9000000008001acc:	29c0607f 	st.d	$r31,$r3,24(0x18)
9000000008001ad0:	02c1c076 	addi.d	$r22,$r3,112(0x70)
9000000008001ad4:	001500fb 	move	$r27,$r7
9000000008001ad8:	001500dc 	move	$r28,$r6
9000000008001adc:	001500ba 	move	$r26,$r5
9000000008001ae0:	29fe62c4 	st.d	$r4,$r22,-104(0xf98)
  uint64 pa, i = 0, ki = 0;
9000000008001ae4:	00150018 	move	$r24,$r0
      panic("uvmcopy: page not present");
    pa = PTE2PA(*pte);
    flags = PTE_FLAGS(*pte);
    if ((mem = kalloc()) == NULL)
      goto err;
    memmove(mem, (char *)(pa | DMWIN_MASK), PGSIZE);
9000000008001ae8:	0324001d 	lu52i.d	$r29,$r0,-1792(0x900)
      kfree(mem);
      goto err;
    }
    i += PGSIZE;
    // 试图在用户进程清理内核页表
    if (mappages(knew, ki, PGSIZE, (uint64)mem, flags & ~PTE_PLV) != 0) {
9000000008001aec:	02bfcc1e 	addi.w	$r30,$r0,-13(0xff3)
9000000008001af0:	50000800 	b	8(0x8) # 9000000008001af8 <uvmcopy+0x5c>
    i += PGSIZE;
9000000008001af4:	001503f8 	move	$r24,$r31
    if ((pte = walk(old, i, 0)) == NULL)
9000000008001af8:	00150006 	move	$r6,$r0
9000000008001afc:	00150305 	move	$r5,$r24
9000000008001b00:	28fe62c4 	ld.d	$r4,$r22,-104(0xf98)
9000000008001b04:	57f573ff 	bl	-2704(0xffff570) # 9000000008001074 <walk>
9000000008001b08:	40008080 	beqz	$r4,128(0x80) # 9000000008001b88 <uvmcopy+0xec>
    if ((*pte & PTE_V) == 0)
9000000008001b0c:	28c00097 	ld.d	$r23,$r4,0
9000000008001b10:	034006ec 	andi	$r12,$r23,0x1
9000000008001b14:	40008180 	beqz	$r12,128(0x80) # 9000000008001b94 <uvmcopy+0xf8>
    pa = PTE2PA(*pte);
9000000008001b18:	15ffffff 	lu12i.w	$r31,-1(0xfffff)
9000000008001b1c:	161fffff 	lu32i.d	$r31,65535(0xffff)
9000000008001b20:	0014feff 	and	$r31,$r23,$r31
    flags = PTE_FLAGS(*pte);
9000000008001b24:	0347fef7 	andi	$r23,$r23,0x1ff
    if ((mem = kalloc()) == NULL)
9000000008001b28:	57f43fff 	bl	-3012(0xffff43c) # 9000000008000f64 <kalloc>
9000000008001b2c:	00150099 	move	$r25,$r4
9000000008001b30:	40008080 	beqz	$r4,128(0x80) # 9000000008001bb0 <uvmcopy+0x114>
    memmove(mem, (char *)(pa | DMWIN_MASK), PGSIZE);
9000000008001b34:	14000026 	lu12i.w	$r6,1(0x1)
9000000008001b38:	001577e5 	or	$r5,$r31,$r29
9000000008001b3c:	57ed7fff 	bl	-4740(0xfffed7c) # 90000000080008b8 <memmove>
    if (mappages(new, i, PGSIZE, (uint64)mem, flags) != 0) {
9000000008001b40:	001502e8 	move	$r8,$r23
9000000008001b44:	00150327 	move	$r7,$r25
9000000008001b48:	14000026 	lu12i.w	$r6,1(0x1)
9000000008001b4c:	00150305 	move	$r5,$r24
9000000008001b50:	00150344 	move	$r4,$r26
9000000008001b54:	57f773ff 	bl	-2192(0xffff770) # 90000000080012c4 <mappages>
9000000008001b58:	44004880 	bnez	$r4,72(0x48) # 9000000008001ba0 <uvmcopy+0x104>
    i += PGSIZE;
9000000008001b5c:	1400003f 	lu12i.w	$r31,1(0x1)
9000000008001b60:	0010ff1f 	add.d	$r31,$r24,$r31
    if (mappages(knew, ki, PGSIZE, (uint64)mem, flags & ~PTE_PLV) != 0) {
9000000008001b64:	0014fae8 	and	$r8,$r23,$r30
9000000008001b68:	00150327 	move	$r7,$r25
9000000008001b6c:	14000026 	lu12i.w	$r6,1(0x1)
9000000008001b70:	00150305 	move	$r5,$r24
9000000008001b74:	00150384 	move	$r4,$r28
9000000008001b78:	57f74fff 	bl	-2228(0xffff74c) # 90000000080012c4 <mappages>
9000000008001b7c:	44003880 	bnez	$r4,56(0x38) # 9000000008001bb4 <uvmcopy+0x118>
  while (i < sz) {
9000000008001b80:	6bff77fb 	bltu	$r31,$r27,-140(0x3ff74) # 9000000008001af4 <uvmcopy+0x58>
9000000008001b84:	50005c00 	b	92(0x5c) # 9000000008001be0 <uvmcopy+0x144>
      panic("uvmcopy: pte should exist");
9000000008001b88:	1c000024 	pcaddu12i	$r4,1(0x1)
9000000008001b8c:	02da6084 	addi.d	$r4,$r4,1688(0x698)
9000000008001b90:	57e673ff 	bl	-6544(0xfffe670) # 9000000008000200 <panic>
      panic("uvmcopy: page not present");
9000000008001b94:	1c000024 	pcaddu12i	$r4,1(0x1)
9000000008001b98:	02dab084 	addi.d	$r4,$r4,1708(0x6ac)
9000000008001b9c:	57e667ff 	bl	-6556(0xfffe664) # 9000000008000200 <panic>
      kfree(mem);
9000000008001ba0:	00150324 	move	$r4,$r25
9000000008001ba4:	57f233ff 	bl	-3536(0xffff230) # 9000000008000dd4 <kfree>
      goto err;
9000000008001ba8:	0015031f 	move	$r31,$r24
9000000008001bac:	50000800 	b	8(0x8) # 9000000008001bb4 <uvmcopy+0x118>
9000000008001bb0:	0015031f 	move	$r31,$r24
    ki += PGSIZE;
  }
  return 0;

err:
  vmunmap(knew, 0, ki / PGSIZE, 0);
9000000008001bb4:	00150007 	move	$r7,$r0
9000000008001bb8:	00453306 	srli.d	$r6,$r24,0xc
9000000008001bbc:	00150005 	move	$r5,$r0
9000000008001bc0:	00150384 	move	$r4,$r28
9000000008001bc4:	57f8f7ff 	bl	-1804(0xffff8f4) # 90000000080014b8 <vmunmap>
  vmunmap(new, 0, i / PGSIZE, 1);
9000000008001bc8:	02800407 	addi.w	$r7,$r0,1(0x1)
9000000008001bcc:	004533e6 	srli.d	$r6,$r31,0xc
9000000008001bd0:	00150005 	move	$r5,$r0
9000000008001bd4:	00150344 	move	$r4,$r26
9000000008001bd8:	57f8e3ff 	bl	-1824(0xffff8e0) # 90000000080014b8 <vmunmap>
  return -1;
9000000008001bdc:	02bffc04 	addi.w	$r4,$r0,-1(0xfff)
}
9000000008001be0:	28c1a061 	ld.d	$r1,$r3,104(0x68)
9000000008001be4:	28c18076 	ld.d	$r22,$r3,96(0x60)
9000000008001be8:	28c16077 	ld.d	$r23,$r3,88(0x58)
9000000008001bec:	28c14078 	ld.d	$r24,$r3,80(0x50)
9000000008001bf0:	28c12079 	ld.d	$r25,$r3,72(0x48)
9000000008001bf4:	28c1007a 	ld.d	$r26,$r3,64(0x40)
9000000008001bf8:	28c0e07b 	ld.d	$r27,$r3,56(0x38)
9000000008001bfc:	28c0c07c 	ld.d	$r28,$r3,48(0x30)
9000000008001c00:	28c0a07d 	ld.d	$r29,$r3,40(0x28)
9000000008001c04:	28c0807e 	ld.d	$r30,$r3,32(0x20)
9000000008001c08:	28c0607f 	ld.d	$r31,$r3,24(0x18)
9000000008001c0c:	02c1c063 	addi.d	$r3,$r3,112(0x70)
9000000008001c10:	4c000020 	jirl	$r0,$r1,0
  return 0;
9000000008001c14:	00150004 	move	$r4,$r0
}
9000000008001c18:	4c000020 	jirl	$r0,$r1,0

9000000008001c1c <uvmclear>:

// mark a PTE invalid for user access.
// used by exec for the user stack guard page.
void uvmclear(pagetable_t pagetable, uint64 va) {
9000000008001c1c:	02ffc063 	addi.d	$r3,$r3,-16(0xff0)
9000000008001c20:	29c02061 	st.d	$r1,$r3,8(0x8)
9000000008001c24:	29c00076 	st.d	$r22,$r3,0
9000000008001c28:	02c04076 	addi.d	$r22,$r3,16(0x10)
  pte_t *pte;

  pte = walk(pagetable, va, 0);
9000000008001c2c:	00150006 	move	$r6,$r0
9000000008001c30:	57f447ff 	bl	-3004(0xffff444) # 9000000008001074 <walk>
  if (pte == NULL)
9000000008001c34:	40002480 	beqz	$r4,36(0x24) # 9000000008001c58 <uvmclear+0x3c>
    panic("uvmclear");
  *pte &= ~PTE_PLV;
9000000008001c38:	28c0008c 	ld.d	$r12,$r4,0
9000000008001c3c:	02bfcc0d 	addi.w	$r13,$r0,-13(0xff3)
9000000008001c40:	0014b58c 	and	$r12,$r12,$r13
9000000008001c44:	29c0008c 	st.d	$r12,$r4,0
}
9000000008001c48:	28c02061 	ld.d	$r1,$r3,8(0x8)
9000000008001c4c:	28c00076 	ld.d	$r22,$r3,0
9000000008001c50:	02c04063 	addi.d	$r3,$r3,16(0x10)
9000000008001c54:	4c000020 	jirl	$r0,$r1,0
    panic("uvmclear");
9000000008001c58:	1c000024 	pcaddu12i	$r4,1(0x1)
9000000008001c5c:	02d82084 	addi.d	$r4,$r4,1544(0x608)
9000000008001c60:	57e5a3ff 	bl	-6752(0xfffe5a0) # 9000000008000200 <panic>

9000000008001c64 <copyout_zero>:

// 向指定的用户地址输出长度为len的0值
int copyout_zero(pagetable_t pagetable, uint64 dstva, uint64 len) {
  uint64 n, va0, pa0;

  while (len > 0) {
9000000008001c64:	4000a4c0 	beqz	$r6,164(0xa4) # 9000000008001d08 <copyout_zero+0xa4>
int copyout_zero(pagetable_t pagetable, uint64 dstva, uint64 len) {
9000000008001c68:	02fec063 	addi.d	$r3,$r3,-80(0xfb0)
9000000008001c6c:	29c12061 	st.d	$r1,$r3,72(0x48)
9000000008001c70:	29c10076 	st.d	$r22,$r3,64(0x40)
9000000008001c74:	29c0e077 	st.d	$r23,$r3,56(0x38)
9000000008001c78:	29c0c078 	st.d	$r24,$r3,48(0x30)
9000000008001c7c:	29c0a079 	st.d	$r25,$r3,40(0x28)
9000000008001c80:	29c0807a 	st.d	$r26,$r3,32(0x20)
9000000008001c84:	29c0607b 	st.d	$r27,$r3,24(0x18)
9000000008001c88:	29c0407c 	st.d	$r28,$r3,16(0x10)
9000000008001c8c:	29c0207d 	st.d	$r29,$r3,8(0x8)
9000000008001c90:	29c0007e 	st.d	$r30,$r3,0
9000000008001c94:	02c14076 	addi.d	$r22,$r3,80(0x50)
9000000008001c98:	0015009b 	move	$r27,$r4
9000000008001c9c:	001500be 	move	$r30,$r5
9000000008001ca0:	001500d8 	move	$r24,$r6
    va0 = PGROUNDDOWN(dstva);
9000000008001ca4:	15fffffc 	lu12i.w	$r28,-1(0xfffff)
    pa0 = walkaddr(pagetable, va0);
    if (pa0 == NULL)
      return -1;
    n = PGSIZE - (dstva - va0);
9000000008001ca8:	1400003a 	lu12i.w	$r26,1(0x1)
    if (n > len)
      n = len;

    memmove((void *)((pa0 + (dstva - va0)) | DMWIN_MASK), 0, n);
9000000008001cac:	0324001d 	lu52i.d	$r29,$r0,-1792(0x900)
    va0 = PGROUNDDOWN(dstva);
9000000008001cb0:	0014f3d9 	and	$r25,$r30,$r28
    pa0 = walkaddr(pagetable, va0);
9000000008001cb4:	00150325 	move	$r5,$r25
9000000008001cb8:	00150364 	move	$r4,$r27
9000000008001cbc:	57f4b3ff 	bl	-2896(0xffff4b0) # 900000000800116c <walkaddr>
    if (pa0 == NULL)
9000000008001cc0:	40005080 	beqz	$r4,80(0x50) # 9000000008001d10 <copyout_zero+0xac>
    n = PGSIZE - (dstva - va0);
9000000008001cc4:	0011fb37 	sub.d	$r23,$r25,$r30
9000000008001cc8:	0010eaf7 	add.d	$r23,$r23,$r26
    if (n > len)
9000000008001ccc:	0012df0c 	sltu	$r12,$r24,$r23
9000000008001cd0:	0013b2f7 	masknez	$r23,$r23,$r12
9000000008001cd4:	0013330c 	maskeqz	$r12,$r24,$r12
9000000008001cd8:	001532f7 	or	$r23,$r23,$r12
    memmove((void *)((pa0 + (dstva - va0)) | DMWIN_MASK), 0, n);
9000000008001cdc:	004082e6 	slli.w	$r6,$r23,0x0
9000000008001ce0:	0010f884 	add.d	$r4,$r4,$r30
9000000008001ce4:	0011e484 	sub.d	$r4,$r4,$r25
9000000008001ce8:	00150005 	move	$r5,$r0
9000000008001cec:	00157484 	or	$r4,$r4,$r29
9000000008001cf0:	57ebcbff 	bl	-5176(0xfffebc8) # 90000000080008b8 <memmove>

    len -= n;
9000000008001cf4:	0011df18 	sub.d	$r24,$r24,$r23
    dstva = va0 + PGSIZE;
9000000008001cf8:	0010eb3e 	add.d	$r30,$r25,$r26
  while (len > 0) {
9000000008001cfc:	47ffb71f 	bnez	$r24,-76(0x7fffb4) # 9000000008001cb0 <copyout_zero+0x4c>
  }
  return 0;
9000000008001d00:	00150004 	move	$r4,$r0
9000000008001d04:	50001000 	b	16(0x10) # 9000000008001d14 <copyout_zero+0xb0>
9000000008001d08:	00150004 	move	$r4,$r0
}
9000000008001d0c:	4c000020 	jirl	$r0,$r1,0
      return -1;
9000000008001d10:	02bffc04 	addi.w	$r4,$r0,-1(0xfff)
}
9000000008001d14:	28c12061 	ld.d	$r1,$r3,72(0x48)
9000000008001d18:	28c10076 	ld.d	$r22,$r3,64(0x40)
9000000008001d1c:	28c0e077 	ld.d	$r23,$r3,56(0x38)
9000000008001d20:	28c0c078 	ld.d	$r24,$r3,48(0x30)
9000000008001d24:	28c0a079 	ld.d	$r25,$r3,40(0x28)
9000000008001d28:	28c0807a 	ld.d	$r26,$r3,32(0x20)
9000000008001d2c:	28c0607b 	ld.d	$r27,$r3,24(0x18)
9000000008001d30:	28c0407c 	ld.d	$r28,$r3,16(0x10)
9000000008001d34:	28c0207d 	ld.d	$r29,$r3,8(0x8)
9000000008001d38:	28c0007e 	ld.d	$r30,$r3,0
9000000008001d3c:	02c14063 	addi.d	$r3,$r3,80(0x50)
9000000008001d40:	4c000020 	jirl	$r0,$r1,0

9000000008001d44 <copyout>:
// Copy len bytes from src to virtual address dstva in a given page table.
// Return 0 on success, -1 on error.
int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) {
  uint64 n, va0, pa0;

  while (len > 0) {
9000000008001d44:	4000b0e0 	beqz	$r7,176(0xb0) # 9000000008001df4 <copyout+0xb0>
int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) {
9000000008001d48:	02fe8063 	addi.d	$r3,$r3,-96(0xfa0)
9000000008001d4c:	29c16061 	st.d	$r1,$r3,88(0x58)
9000000008001d50:	29c14076 	st.d	$r22,$r3,80(0x50)
9000000008001d54:	29c12077 	st.d	$r23,$r3,72(0x48)
9000000008001d58:	29c10078 	st.d	$r24,$r3,64(0x40)
9000000008001d5c:	29c0e079 	st.d	$r25,$r3,56(0x38)
9000000008001d60:	29c0c07a 	st.d	$r26,$r3,48(0x30)
9000000008001d64:	29c0a07b 	st.d	$r27,$r3,40(0x28)
9000000008001d68:	29c0807c 	st.d	$r28,$r3,32(0x20)
9000000008001d6c:	29c0607d 	st.d	$r29,$r3,24(0x18)
9000000008001d70:	29c0407e 	st.d	$r30,$r3,16(0x10)
9000000008001d74:	29c0207f 	st.d	$r31,$r3,8(0x8)
9000000008001d78:	02c18076 	addi.d	$r22,$r3,96(0x60)
9000000008001d7c:	0015009d 	move	$r29,$r4
9000000008001d80:	001500ba 	move	$r26,$r5
9000000008001d84:	001500db 	move	$r27,$r6
9000000008001d88:	001500f8 	move	$r24,$r7
    va0 = PGROUNDDOWN(dstva);
9000000008001d8c:	15fffffe 	lu12i.w	$r30,-1(0xfffff)
    pa0 = walkaddr(pagetable, va0);
    if (pa0 == NULL)
      return -1;
    n = PGSIZE - (dstva - va0);
9000000008001d90:	1400003c 	lu12i.w	$r28,1(0x1)
    if (n > len)
      n = len;
    memmove((void *)((pa0 + (dstva - va0)) | DMWIN_MASK), src, n);
9000000008001d94:	0324001f 	lu52i.d	$r31,$r0,-1792(0x900)
    va0 = PGROUNDDOWN(dstva);
9000000008001d98:	0014fb59 	and	$r25,$r26,$r30
    pa0 = walkaddr(pagetable, va0);
9000000008001d9c:	00150325 	move	$r5,$r25
9000000008001da0:	001503a4 	move	$r4,$r29
9000000008001da4:	57f3cbff 	bl	-3128(0xffff3c8) # 900000000800116c <walkaddr>
    if (pa0 == NULL)
9000000008001da8:	40005480 	beqz	$r4,84(0x54) # 9000000008001dfc <copyout+0xb8>
    n = PGSIZE - (dstva - va0);
9000000008001dac:	0011eb37 	sub.d	$r23,$r25,$r26
9000000008001db0:	0010f2f7 	add.d	$r23,$r23,$r28
    if (n > len)
9000000008001db4:	0012df0c 	sltu	$r12,$r24,$r23
9000000008001db8:	0013b2f7 	masknez	$r23,$r23,$r12
9000000008001dbc:	0013330c 	maskeqz	$r12,$r24,$r12
9000000008001dc0:	001532f7 	or	$r23,$r23,$r12
    memmove((void *)((pa0 + (dstva - va0)) | DMWIN_MASK), src, n);
9000000008001dc4:	004082e6 	slli.w	$r6,$r23,0x0
9000000008001dc8:	0010e884 	add.d	$r4,$r4,$r26
9000000008001dcc:	0011e484 	sub.d	$r4,$r4,$r25
9000000008001dd0:	00150365 	move	$r5,$r27
9000000008001dd4:	00157c84 	or	$r4,$r4,$r31
9000000008001dd8:	57eae3ff 	bl	-5408(0xfffeae0) # 90000000080008b8 <memmove>

    len -= n;
9000000008001ddc:	0011df18 	sub.d	$r24,$r24,$r23
    src += n;
9000000008001de0:	0010df7b 	add.d	$r27,$r27,$r23
    dstva = va0 + PGSIZE;
9000000008001de4:	0010f33a 	add.d	$r26,$r25,$r28
  while (len > 0) {
9000000008001de8:	47ffb31f 	bnez	$r24,-80(0x7fffb0) # 9000000008001d98 <copyout+0x54>
  }
  return 0;
9000000008001dec:	00150004 	move	$r4,$r0
9000000008001df0:	50001000 	b	16(0x10) # 9000000008001e00 <copyout+0xbc>
9000000008001df4:	00150004 	move	$r4,$r0
}
9000000008001df8:	4c000020 	jirl	$r0,$r1,0
      return -1;
9000000008001dfc:	02bffc04 	addi.w	$r4,$r0,-1(0xfff)
}
9000000008001e00:	28c16061 	ld.d	$r1,$r3,88(0x58)
9000000008001e04:	28c14076 	ld.d	$r22,$r3,80(0x50)
9000000008001e08:	28c12077 	ld.d	$r23,$r3,72(0x48)
9000000008001e0c:	28c10078 	ld.d	$r24,$r3,64(0x40)
9000000008001e10:	28c0e079 	ld.d	$r25,$r3,56(0x38)
9000000008001e14:	28c0c07a 	ld.d	$r26,$r3,48(0x30)
9000000008001e18:	28c0a07b 	ld.d	$r27,$r3,40(0x28)
9000000008001e1c:	28c0807c 	ld.d	$r28,$r3,32(0x20)
9000000008001e20:	28c0607d 	ld.d	$r29,$r3,24(0x18)
9000000008001e24:	28c0407e 	ld.d	$r30,$r3,16(0x10)
9000000008001e28:	28c0207f 	ld.d	$r31,$r3,8(0x8)
9000000008001e2c:	02c18063 	addi.d	$r3,$r3,96(0x60)
9000000008001e30:	4c000020 	jirl	$r0,$r1,0

9000000008001e34 <copyin>:
// Copy len bytes to dst from virtual address srcva in a given page table.
// Return 0 on success, -1 on error.
int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) {
  uint64 n, va0, pa0;

  while (len > 0) {
9000000008001e34:	4000f4e0 	beqz	$r7,244(0xf4) # 9000000008001f28 <copyin+0xf4>
int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) {
9000000008001e38:	02fe8063 	addi.d	$r3,$r3,-96(0xfa0)
9000000008001e3c:	29c16061 	st.d	$r1,$r3,88(0x58)
9000000008001e40:	29c14076 	st.d	$r22,$r3,80(0x50)
9000000008001e44:	29c12077 	st.d	$r23,$r3,72(0x48)
9000000008001e48:	29c10078 	st.d	$r24,$r3,64(0x40)
9000000008001e4c:	29c0e079 	st.d	$r25,$r3,56(0x38)
9000000008001e50:	29c0c07a 	st.d	$r26,$r3,48(0x30)
9000000008001e54:	29c0a07b 	st.d	$r27,$r3,40(0x28)
9000000008001e58:	29c0807c 	st.d	$r28,$r3,32(0x20)
9000000008001e5c:	29c0607d 	st.d	$r29,$r3,24(0x18)
9000000008001e60:	29c0407e 	st.d	$r30,$r3,16(0x10)
9000000008001e64:	29c0207f 	st.d	$r31,$r3,8(0x8)
9000000008001e68:	02c18076 	addi.d	$r22,$r3,96(0x60)
9000000008001e6c:	0015009d 	move	$r29,$r4
9000000008001e70:	001500bb 	move	$r27,$r5
9000000008001e74:	001500da 	move	$r26,$r6
9000000008001e78:	001500f8 	move	$r24,$r7
    va0 = PGROUNDDOWN(srcva);
9000000008001e7c:	15fffffe 	lu12i.w	$r30,-1(0xfffff)
    pa0 = walkaddr(pagetable, va0);
    if (pa0 == NULL) {
      printf("copyin: pa0 is NULL\n");
      return -1;
    }
    n = PGSIZE - (srcva - va0);
9000000008001e80:	1400003c 	lu12i.w	$r28,1(0x1)
    if (n > len)
      n = len;
    memmove(dst, (void *)((pa0 + (srcva - va0)) | DMWIN_MASK), n);
9000000008001e84:	0324001f 	lu52i.d	$r31,$r0,-1792(0x900)
    va0 = PGROUNDDOWN(srcva);
9000000008001e88:	0014fb59 	and	$r25,$r26,$r30
    pa0 = walkaddr(pagetable, va0);
9000000008001e8c:	00150325 	move	$r5,$r25
9000000008001e90:	001503a4 	move	$r4,$r29
9000000008001e94:	57f2dbff 	bl	-3368(0xffff2d8) # 900000000800116c <walkaddr>
    if (pa0 == NULL) {
9000000008001e98:	40004c80 	beqz	$r4,76(0x4c) # 9000000008001ee4 <copyin+0xb0>
    n = PGSIZE - (srcva - va0);
9000000008001e9c:	0011eb37 	sub.d	$r23,$r25,$r26
9000000008001ea0:	0010f2f7 	add.d	$r23,$r23,$r28
    if (n > len)
9000000008001ea4:	0012df0c 	sltu	$r12,$r24,$r23
9000000008001ea8:	0013b2f7 	masknez	$r23,$r23,$r12
9000000008001eac:	0013330c 	maskeqz	$r12,$r24,$r12
9000000008001eb0:	001532f7 	or	$r23,$r23,$r12
    memmove(dst, (void *)((pa0 + (srcva - va0)) | DMWIN_MASK), n);
9000000008001eb4:	004082e6 	slli.w	$r6,$r23,0x0
9000000008001eb8:	0010e884 	add.d	$r4,$r4,$r26
9000000008001ebc:	0011e485 	sub.d	$r5,$r4,$r25
9000000008001ec0:	00157ca5 	or	$r5,$r5,$r31
9000000008001ec4:	00150364 	move	$r4,$r27
9000000008001ec8:	57e9f3ff 	bl	-5648(0xfffe9f0) # 90000000080008b8 <memmove>

    len -= n;
9000000008001ecc:	0011df18 	sub.d	$r24,$r24,$r23
    dst += n;
9000000008001ed0:	0010df7b 	add.d	$r27,$r27,$r23
    srcva = va0 + PGSIZE;
9000000008001ed4:	0010f33a 	add.d	$r26,$r25,$r28
  while (len > 0) {
9000000008001ed8:	47ffb31f 	bnez	$r24,-80(0x7fffb0) # 9000000008001e88 <copyin+0x54>
  }
  return 0;
9000000008001edc:	00150004 	move	$r4,$r0
9000000008001ee0:	50001400 	b	20(0x14) # 9000000008001ef4 <copyin+0xc0>
      printf("copyin: pa0 is NULL\n");
9000000008001ee4:	1c000024 	pcaddu12i	$r4,1(0x1)
9000000008001ee8:	02ce3084 	addi.d	$r4,$r4,908(0x38c)
9000000008001eec:	57e387ff 	bl	-7292(0xfffe384) # 9000000008000270 <printf>
      return -1;
9000000008001ef0:	02bffc04 	addi.w	$r4,$r0,-1(0xfff)
}
9000000008001ef4:	28c16061 	ld.d	$r1,$r3,88(0x58)
9000000008001ef8:	28c14076 	ld.d	$r22,$r3,80(0x50)
9000000008001efc:	28c12077 	ld.d	$r23,$r3,72(0x48)
9000000008001f00:	28c10078 	ld.d	$r24,$r3,64(0x40)
9000000008001f04:	28c0e079 	ld.d	$r25,$r3,56(0x38)
9000000008001f08:	28c0c07a 	ld.d	$r26,$r3,48(0x30)
9000000008001f0c:	28c0a07b 	ld.d	$r27,$r3,40(0x28)
9000000008001f10:	28c0807c 	ld.d	$r28,$r3,32(0x20)
9000000008001f14:	28c0607d 	ld.d	$r29,$r3,24(0x18)
9000000008001f18:	28c0407e 	ld.d	$r30,$r3,16(0x10)
9000000008001f1c:	28c0207f 	ld.d	$r31,$r3,8(0x8)
9000000008001f20:	02c18063 	addi.d	$r3,$r3,96(0x60)
9000000008001f24:	4c000020 	jirl	$r0,$r1,0
  return 0;
9000000008001f28:	00150004 	move	$r4,$r0
}
9000000008001f2c:	4c000020 	jirl	$r0,$r1,0

9000000008001f30 <copyinstr>:

int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max) {
  uint64 n, va0, pa0;
  int got_null = 0;

  while (got_null == 0 && max > 0) {
9000000008001f30:	40013ce0 	beqz	$r7,316(0x13c) # 900000000800206c <copyinstr+0x13c>
int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max) {
9000000008001f34:	02fe8063 	addi.d	$r3,$r3,-96(0xfa0)
9000000008001f38:	29c16061 	st.d	$r1,$r3,88(0x58)
9000000008001f3c:	29c14076 	st.d	$r22,$r3,80(0x50)
9000000008001f40:	29c12077 	st.d	$r23,$r3,72(0x48)
9000000008001f44:	29c10078 	st.d	$r24,$r3,64(0x40)
9000000008001f48:	29c0e079 	st.d	$r25,$r3,56(0x38)
9000000008001f4c:	29c0c07a 	st.d	$r26,$r3,48(0x30)
9000000008001f50:	29c0a07b 	st.d	$r27,$r3,40(0x28)
9000000008001f54:	29c0807c 	st.d	$r28,$r3,32(0x20)
9000000008001f58:	29c0607d 	st.d	$r29,$r3,24(0x18)
9000000008001f5c:	29c0407e 	st.d	$r30,$r3,16(0x10)
9000000008001f60:	29c0207f 	st.d	$r31,$r3,8(0x8)
9000000008001f64:	02c18076 	addi.d	$r22,$r3,96(0x60)
9000000008001f68:	0015009c 	move	$r28,$r4
9000000008001f6c:	001500b7 	move	$r23,$r5
9000000008001f70:	001500df 	move	$r31,$r6
9000000008001f74:	001500f8 	move	$r24,$r7
    va0 = PGROUNDDOWN(srcva);
9000000008001f78:	15fffffb 	lu12i.w	$r27,-1(0xfffff)
    pa0 = walkaddr(pagetable, va0);
    if (pa0 == NULL)
      return -1;
    n = PGSIZE - (srcva - va0);
9000000008001f7c:	1400003a 	lu12i.w	$r26,1(0x1)
    if (n > max)
      n = max;

    char *p = (char *) ((pa0 + (srcva - va0)) | DMWIN_MASK);
9000000008001f80:	0324001d 	lu52i.d	$r29,$r0,-1792(0x900)
9000000008001f84:	0280041e 	addi.w	$r30,$r0,1(0x1)
9000000008001f88:	50001800 	b	24(0x18) # 9000000008001fa0 <copyinstr+0x70>
    while (n > 0) {
      if (*p == '\0') {
9000000008001f8c:	001502ec 	move	$r12,$r23
9000000008001f90:	50008800 	b	136(0x88) # 9000000008002018 <copyinstr+0xe8>
        *dst = *p;
      }
      --n;
      --max;
      p++;
      dst++;
9000000008001f94:	001501d7 	move	$r23,$r14
    }

    srcva = va0 + PGSIZE;
9000000008001f98:	0010eb3f 	add.d	$r31,$r25,$r26
  while (got_null == 0 && max > 0) {
9000000008001f9c:	4000c300 	beqz	$r24,192(0xc0) # 900000000800205c <copyinstr+0x12c>
    va0 = PGROUNDDOWN(srcva);
9000000008001fa0:	0014eff9 	and	$r25,$r31,$r27
    pa0 = walkaddr(pagetable, va0);
9000000008001fa4:	00150325 	move	$r5,$r25
9000000008001fa8:	00150384 	move	$r4,$r28
9000000008001fac:	57f1c3ff 	bl	-3648(0xffff1c0) # 900000000800116c <walkaddr>
    if (pa0 == NULL)
9000000008001fb0:	4000b480 	beqz	$r4,180(0xb4) # 9000000008002064 <copyinstr+0x134>
    n = PGSIZE - (srcva - va0);
9000000008001fb4:	0011ff2c 	sub.d	$r12,$r25,$r31
9000000008001fb8:	0010e98c 	add.d	$r12,$r12,$r26
    if (n > max)
9000000008001fbc:	0012b30d 	sltu	$r13,$r24,$r12
9000000008001fc0:	0013b58e 	masknez	$r14,$r12,$r13
9000000008001fc4:	0013370d 	maskeqz	$r13,$r24,$r13
9000000008001fc8:	001535ce 	or	$r14,$r14,$r13
    char *p = (char *) ((pa0 + (srcva - va0)) | DMWIN_MASK);
9000000008001fcc:	0010fc84 	add.d	$r4,$r4,$r31
9000000008001fd0:	0011e484 	sub.d	$r4,$r4,$r25
9000000008001fd4:	00157484 	or	$r4,$r4,$r29
    while (n > 0) {
9000000008001fd8:	43ffc1df 	beqz	$r14,-64(0x7fffc0) # 9000000008001f98 <copyinstr+0x68>
      if (*p == '\0') {
9000000008001fdc:	2800008d 	ld.b	$r13,$r4,0
9000000008001fe0:	43ffadbf 	beqz	$r13,-84(0x7fffac) # 9000000008001f8c <copyinstr+0x5c>
9000000008001fe4:	0010baee 	add.d	$r14,$r23,$r14
9000000008001fe8:	001502ec 	move	$r12,$r23
9000000008001fec:	02ffff18 	addi.d	$r24,$r24,-1(0xfff)
9000000008001ff0:	0010df0f 	add.d	$r15,$r24,$r23
9000000008001ff4:	0011dfd7 	sub.d	$r23,$r30,$r23
9000000008001ff8:	001092f7 	add.d	$r23,$r23,$r4
        *dst = *p;
9000000008001ffc:	2900018d 	st.b	$r13,$r12,0
      --max;
9000000008002000:	0011b1f8 	sub.d	$r24,$r15,$r12
      p++;
9000000008002004:	0010b2ed 	add.d	$r13,$r23,$r12
      dst++;
9000000008002008:	02c0058c 	addi.d	$r12,$r12,1(0x1)
    while (n > 0) {
900000000800200c:	5bff89cc 	beq	$r14,$r12,-120(0x3ff88) # 9000000008001f94 <copyinstr+0x64>
      if (*p == '\0') {
9000000008002010:	280001ad 	ld.b	$r13,$r13,0
9000000008002014:	47ffe9bf 	bnez	$r13,-24(0x7fffe8) # 9000000008001ffc <copyinstr+0xcc>
        *dst = '\0';
9000000008002018:	29000180 	st.b	$r0,$r12,0
900000000800201c:	0280040c 	addi.w	$r12,$r0,1(0x1)
  }
  if (got_null) {
9000000008002020:	0240058c 	sltui	$r12,$r12,1(0x1)
9000000008002024:	0011b004 	sub.d	$r4,$r0,$r12
    return 0;
  } else {
    return -1;
  }
}
9000000008002028:	28c16061 	ld.d	$r1,$r3,88(0x58)
900000000800202c:	28c14076 	ld.d	$r22,$r3,80(0x50)
9000000008002030:	28c12077 	ld.d	$r23,$r3,72(0x48)
9000000008002034:	28c10078 	ld.d	$r24,$r3,64(0x40)
9000000008002038:	28c0e079 	ld.d	$r25,$r3,56(0x38)
900000000800203c:	28c0c07a 	ld.d	$r26,$r3,48(0x30)
9000000008002040:	28c0a07b 	ld.d	$r27,$r3,40(0x28)
9000000008002044:	28c0807c 	ld.d	$r28,$r3,32(0x20)
9000000008002048:	28c0607d 	ld.d	$r29,$r3,24(0x18)
900000000800204c:	28c0407e 	ld.d	$r30,$r3,16(0x10)
9000000008002050:	28c0207f 	ld.d	$r31,$r3,8(0x8)
9000000008002054:	02c18063 	addi.d	$r3,$r3,96(0x60)
9000000008002058:	4c000020 	jirl	$r0,$r1,0
900000000800205c:	0015000c 	move	$r12,$r0
9000000008002060:	53ffc3ff 	b	-64(0xfffffc0) # 9000000008002020 <copyinstr+0xf0>
      return -1;
9000000008002064:	02bffc04 	addi.w	$r4,$r0,-1(0xfff)
9000000008002068:	53ffc3ff 	b	-64(0xfffffc0) # 9000000008002028 <copyinstr+0xf8>
  int got_null = 0;
900000000800206c:	0015000c 	move	$r12,$r0
  if (got_null) {
9000000008002070:	0240058c 	sltui	$r12,$r12,1(0x1)
9000000008002074:	0011b004 	sub.d	$r4,$r0,$r12
}
9000000008002078:	4c000020 	jirl	$r0,$r1,0

900000000800207c <experm>:

uint64 experm(pagetable_t pagetable, uint64 va, uint64 perm) {
  pte_t *pte;
  uint64 pa;

  if (va >= MAXVA)
900000000800207c:	1400200c 	lu12i.w	$r12,256(0x100)
9000000008002080:	68000cac 	bltu	$r5,$r12,12(0xc) # 900000000800208c <experm+0x10>
    return NULL;
9000000008002084:	00150004 	move	$r4,$r0
  if ((*pte & PTE_PLV) == 0)
    return NULL;
  *pte |= perm;
  pa = PTE2PA(*pte);
  return pa;
}
9000000008002088:	4c000020 	jirl	$r0,$r1,0
uint64 experm(pagetable_t pagetable, uint64 va, uint64 perm) {
900000000800208c:	02ff8063 	addi.d	$r3,$r3,-32(0xfe0)
9000000008002090:	29c06061 	st.d	$r1,$r3,24(0x18)
9000000008002094:	29c04076 	st.d	$r22,$r3,16(0x10)
9000000008002098:	29c02077 	st.d	$r23,$r3,8(0x8)
900000000800209c:	02c08076 	addi.d	$r22,$r3,32(0x20)
90000000080020a0:	001500d7 	move	$r23,$r6
  pte = walk(pagetable, va, 0);
90000000080020a4:	00150006 	move	$r6,$r0
90000000080020a8:	57efcfff 	bl	-4148(0xfffefcc) # 9000000008001074 <walk>
90000000080020ac:	0015008c 	move	$r12,$r4
    return NULL;
90000000080020b0:	00150004 	move	$r4,$r0
  if (pte == 0)
90000000080020b4:	40002d80 	beqz	$r12,44(0x2c) # 90000000080020e0 <experm+0x64>
  if ((*pte & PTE_V) == 0)
90000000080020b8:	28c00186 	ld.d	$r6,$r12,0
90000000080020bc:	034004c4 	andi	$r4,$r6,0x1
90000000080020c0:	40002080 	beqz	$r4,32(0x20) # 90000000080020e0 <experm+0x64>
  if ((*pte & PTE_PLV) == 0)
90000000080020c4:	034030c4 	andi	$r4,$r6,0xc
90000000080020c8:	40001880 	beqz	$r4,24(0x18) # 90000000080020e0 <experm+0x64>
  *pte |= perm;
90000000080020cc:	00155cc6 	or	$r6,$r6,$r23
90000000080020d0:	29c00186 	st.d	$r6,$r12,0
  pa = PTE2PA(*pte);
90000000080020d4:	15ffffe4 	lu12i.w	$r4,-1(0xfffff)
90000000080020d8:	161fffe4 	lu32i.d	$r4,65535(0xffff)
90000000080020dc:	001490c4 	and	$r4,$r6,$r4
}
90000000080020e0:	28c06061 	ld.d	$r1,$r3,24(0x18)
90000000080020e4:	28c04076 	ld.d	$r22,$r3,16(0x10)
90000000080020e8:	28c02077 	ld.d	$r23,$r3,8(0x8)
90000000080020ec:	02c08063 	addi.d	$r3,$r3,32(0x20)
90000000080020f0:	4c000020 	jirl	$r0,$r1,0

90000000080020f4 <swtch>:
90000000080020f4:	29c00081 	st.d	$r1,$r4,0
90000000080020f8:	29c02083 	st.d	$r3,$r4,8(0x8)
90000000080020fc:	29c04097 	st.d	$r23,$r4,16(0x10)
9000000008002100:	29c06098 	st.d	$r24,$r4,24(0x18)
9000000008002104:	29c08099 	st.d	$r25,$r4,32(0x20)
9000000008002108:	29c0a09a 	st.d	$r26,$r4,40(0x28)
900000000800210c:	29c0c09b 	st.d	$r27,$r4,48(0x30)
9000000008002110:	29c0e09c 	st.d	$r28,$r4,56(0x38)
9000000008002114:	29c1009d 	st.d	$r29,$r4,64(0x40)
9000000008002118:	29c1209e 	st.d	$r30,$r4,72(0x48)
900000000800211c:	29c1409f 	st.d	$r31,$r4,80(0x50)
9000000008002120:	29c16096 	st.d	$r22,$r4,88(0x58)
9000000008002124:	28c000a1 	ld.d	$r1,$r5,0
9000000008002128:	28c020a3 	ld.d	$r3,$r5,8(0x8)
900000000800212c:	28c040b7 	ld.d	$r23,$r5,16(0x10)
9000000008002130:	28c060b8 	ld.d	$r24,$r5,24(0x18)
9000000008002134:	28c080b9 	ld.d	$r25,$r5,32(0x20)
9000000008002138:	28c0a0ba 	ld.d	$r26,$r5,40(0x28)
900000000800213c:	28c0c0bb 	ld.d	$r27,$r5,48(0x30)
9000000008002140:	28c0e0bc 	ld.d	$r28,$r5,56(0x38)
9000000008002144:	28c100bd 	ld.d	$r29,$r5,64(0x40)
9000000008002148:	28c120be 	ld.d	$r30,$r5,72(0x48)
900000000800214c:	28c140bf 	ld.d	$r31,$r5,80(0x50)
9000000008002150:	28c160b6 	ld.d	$r22,$r5,88(0x58)
9000000008002154:	4c000020 	jirl	$r0,$r1,0
	...
