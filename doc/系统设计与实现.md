> by wty
# Loongarch64虚地址管理方式
LA64物理地址长度PALEN长度通过CSR定义，内存物理地址范围在$0 \sim 2^{PALEAN}$之间，PALEN不大于60。
以PALEN = 48 的情况为例， 此时虚拟页表如下：

![](doc/picture/Pasted%20image%2020240520184848.png)
LA64采用虚双页号的设计，每一个TLB表项都可以分为2个部分：比较部分和物理部分。
TLB表项的比较部分包括：
- 存在位(E)，1比特。为1时表示TLB表项非空，可以参与查找分配
- 地址空间标志(ASID)，10比特。用于区分不同进程中相同的虚拟地址，避免进程切换时清空整个TLB带来的性能损失。操作系统为每个进程分配了唯一的ASID，TLB在进行查找时除了比对地址信息一致，还要比对ASID信息
- 全局标志位(G)，1比特。当该位为1时，查找时不进行ASID是否一致性的检查。
- 页大小(PS)，6比特。仅在MTLB中出现，用于指定大页页表的页表项存放的页大小。数值是页大小的幂指数。
- **虚双页号**，(VALEN - 13)比特。在LA64下，每个页表存放相邻的一对奇偶相邻页表信息，所以TLB页表中存放虚页号的是系统中虚页号/2 的内容，即虚页号的最低位不需要存放在TLB中。查找TLB时根据被查找虚页号的最低位决定选择时奇数号页还是偶数号页。

物理部分，PPN表示物理页号，(PALEN-12)比特，其余页表转换信息包括：
- 有效位(V)，1比特。为1表示页表项有效并且被访问过。
- 脏位(D)，1比特。为1时表示页表项对应的地址范围内有脏数据。
- 不可读位(NR)，1比特。为1时表示该页表项所在的地址空间上不允许执行load操作。
- 不可执行位(NX)，1比特。为1表示该页表项所在的地址空间上不允许执行取指操作。
- 存储访问类型(MAT，2比特。控制落在页表项所在地址空间上访存操作的存储访问类型。
- 特权等级(PLV)，2比特。
- 受限特权等级使能(RPLV)，1比特。页表项是否仅被对应特权等级的程序访问的控制位。为0时，该页表项可以被任何特权等级不低于PLV的程序访问；当RPLV=1时，该页表项可以被等级等于PLV的程序访问。

# 地址空间布局


# 内存管理
## 物理内存管理
实现程序内存空间的访问，首要的是实现物理内存空间的分配。avx-Loongarch64 使用kalloc.c 文件负责物理内存的管理，包括内存的释放，访问上锁的控制以及内存的初始化等。
内存分配采用空闲链表的方式，空闲的页（每页大小为4096B）采用`struct run` 结构体负责页的分配与释放；该结构体实现的就是单向的空闲链表，链表的每个结点表示1个实际物理页。
其他的数据结构还有：
- `kmem`：在kalloc.c 模块中唯一定义的全局变量，用于访问空闲链表`freelist`，该链表使用上文`struct run` 结构实现。`kmem` 同时维护访问内存的自旋锁`spinlock`，以及剩余空闲页数`npage`

```c
struct {
	struct spinlock lock;
	struct run *freelist;
	uint64 npage;
} kmem;
```

内核启动，调用初始化函数kminit。它首先初始化kmem中的自旋锁，然后调用freerange() 函数将内核结束地址kernel_end 到物理内存上限的RAMSTOP之间的所有物理内存页添加到空闲列表中：
```c
void kinit() {
	initlock(&kmem.lock, "kmem");
	kmem.freelist = 0;
	kmem.npage = 0;
	freerange(kernel_end, (void *)RAMSTOP);
	printf("kernel_end: %p, RAMSTOP: %p\n", kernel_end, (void *)RAMSTOP);
}
```

`freerange()`用于将一段物理内存地址范围内的所有物理内存释放，然后加入到空闲链表中。它首先将起始地址向上取整到页的边界，然后从起始地址开始，每次增加1个页的大小，然后依次释放每个物理内存页。

`kfree()`函数用于释放1个物理的内存页。函数首先检查传入物理地址的合法性，检查通过则清空物理页的内容，填充垃圾字节，调用`run` 结构体将空页加入到空闲链表中。
`kalloc()`负责分配1个物理的内存页。如果空闲链表为空，返回`NULL` 表示分配失败；否则取出链表的头结点，清空该页的内容后返回。
`freemem_amount()` 返回当前空闲物理内存容量，返回方式为空闲页总量乘上每页的固定字节数（4096字节），返回值为物理内存的字节数。

## 虚拟内存管理


# 进程管理
进程管理的模块主要分为：初始化、进程调用、进程切换等。
## 进程控制块
操作系统使用进程控制块将运行中的程序进行封装，利于操作系统的管理。进程控制块的结构如下所示。进程控制块存储进程的状态，是内核对进程进行管理的基本单元，同时，控制块的丰富程度反映了操作系统的复杂程度、交互能力和调度性能。
```c
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  struct proc *parent;         // Parent process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID
  int uid;                     // Process User ID
  int gid;                     // Process Group ID
  int pgid;
  
  uint64 filelimit;
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  
  pagetable_t pagetable;       // User page table
  pagetable_t kpagetable;      // Kernel page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  int *exec_close;             // Open files
  struct dirent *cwd;          // Current directory
  char name[16];               // Process name (debugging)
  int tmask;                    // trace mask
  struct vma *vma;
  int ktime;
  int utime;
};
```

## 进程状态
进程状态定义如下：
```c
enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
```
各状态解释如下：
- `UNUSED`：表示进程控制块没有对应的进程
- `USED`：表示进程控制块存在对应的进程
- `SLEEPING`：进程由于等待资源等原因没有运行
- `RUNNABLE`：进程进入等待资源调度的环节
- `RUNNING`：表示进程正在运行
- `ZOMBIE`：进程被杀死，但是资源没有回收，处于”僵死“状态


## 进程分配
