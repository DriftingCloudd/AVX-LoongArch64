# 1 NPUcore+LA 
## 1.1 内存地址映射布局
对于用户态，使用0扩展地址作为虚拟空间
对于内核态，使用0扩展地址空间访问物理内存，然后对页表映射使用1扩展的地址
这样做可以
- 利用直接映射减少恒等映射的开销
- 在上下文无需存储页表地址，可以直接切换地址空间

## 1.2 不对其读写问题
LLVM生成的代码不支持生成严格对齐的代码。  
解决方案：手动模拟不对齐的指令的执行

## 1.3 TLB与页表结构
TLB miss时 LA需要手动进行TLB重填
。LoongArch 目前是手动重填 TLB 的。其重填的一般
流程如下：
1. 硬件提供页表地址PGD
 (a) LoongArch 有两个页表 PGDL 和 PGDH，分别对应符号扩展的
全1段和0段。
(b) 如果触发重填的地址来自 0 段, 则重填的页表 PGD 此时等于
PGDL, 否则 PGD 此时等于PGDH。这样一来,页表实际上分为
了高地址和低地址页表,可以用作不同的功能。
2. 硬件触发TLB异常，跳转到TLBRENTRYCSR所指向的地址
3. 操作系统会响应异常，通过读取PGD状态控制寄存器,获取最高一级
页表目录
4. 根据虚拟地址计算出对应的物理页框号。然后在主存中查找该物理页
框的对应页表项，然后返回该页表项的物理地址. 为了加速页表重填,
 LoongArch 提供了下列特性:
 (a) LoongArch 的 TLB 以双页形式组织，目的是减少重填次数。具
体来说，LoongArch 的 TLB 的索引单位是VPPN（Virtual Page
 Pair Number），为虚拟页号去掉最第一位。每个VPPN对应VPN
为VPPN×2+VPN[12] 的一对奇数页和偶数页两页的物理地址。
考虑到TLB 重填的局部性，这样最多可以减少一半的TLB 重
填。
(b) LoongArch 提供 LDDIR 和 LDPTE 两种指令进行页表遍历，通
过TLBRBADV寄存器提供重填的虚拟地址，并以此为基础获得
各级页表的索引号。LDDIR是用于给定非末级页表起始地址，求
取本级页表项（或者说下一级页表起始地址），其格式为 (其中
imm 为页表级数。以 rj 为页表起始地址，rd 为目的寄存器。)：
LDDIR rd, rj, imm,
 5. 返回页表项后，处理器将该对页表项用TLBFILL写入TLB中，以便
下次使用该虚拟地址时，能够直接从TLB中获取物理地址信息，而不
需要再次触发TLB重填。在TLB更新后，处理器会重新执行之前的
指令或内存访问操作，这次操作可以直接从TLB中获取到物理地
NPUCore+LA采用了模仿RISC架构处理页表重填的方式：

解决方式：
直接用汇编代码对各层页表项进行处理. 首先, 页表是一棵前缀树, 其部分没有被映射
的节点是空的,因此如果直接使用上述的LDPTE和LDDIR,由于其只是单
纯的将异常地址的对应段取出作相加,因此对空的地址会计算出错误的地址,
而不是和其他RISC 一样触发异常. 因此,非最底层页表的叶结点(空表项)
必须要手工判断,并对其错误的表项,填写无读写权限的TLB表项
