> by wty

# 内存管理
## 物理内存管理
实现程序内存空间的访问，首要的是实现物理内存空间的分配。avx-Loongarch64 使用kalloc.c 文件负责物理内存的管理，包括内存的释放，访问上锁的控制以及内存的初始化等。
内存分配采用空闲链表的方式，空闲的页（每页大小为4096B）采用`struct run` 结构体负责页的分配与释放；该结构体实现的就是单向的空闲链表，链表的每个结点表示1个实际物理页。
其他的数据结构还有：
- `kmem`：在kalloc.c 模块中唯一定义的全局变量，用于访问空闲链表`freelist`，该链表使用上文`struct run` 结构实现。`kmem` 同时维护访问内存的自旋锁`spinlock`，以及剩余空闲页数`npage`

```c
struct {
	struct spinlock lock;
	struct run *freelist;
	uint64 npage;
} kmem;
```

内核启动，调用初始化函数kminit。它首先初始化kmem中的自旋锁，然后调用freerange() 函数将内核结束地址kernel_end 到物理内存上限的RAMSTOP之间的所有物理内存页添加到空闲列表中：
```c
void kinit() {
	initlock(&kmem.lock, "kmem");
	kmem.freelist = 0;
	kmem.npage = 0;
	freerange(kernel_end, (void *)RAMSTOP);
	printf("kernel_end: %p, RAMSTOP: %p\n", kernel_end, (void *)RAMSTOP);
}
```

`freerange()`用于将一段物理内存地址范围内的所有物理内存释放，然后加入到空闲链表中。它首先将起始地址向上取整到页的边界，然后从起始地址开始，每次增加1个页的大小，然后依次释放每个物理内存页。

`kfree()`函数用于释放1个物理的内存页。函数首先检查传入物理地址的合法性，检查通过则清空物理页的内容，填充垃圾字节，调用`run` 结构体将空页加入到空闲链表中。
`kalloc()`负责分配1个物理的内存页。如果空闲链表为空，返回`NULL` 表示分配失败；否则取出链表的头结点，清空该页的内容后返回。
`freemem_amount()` 返回当前空闲物理内存容量，返回方式为空闲页总量乘上每页的固定字节数（4096字节），返回值为物理内存的字节数。

## 虚拟内存管理
虚拟内存管理使用的工具是页表，avx-loongarch64使用PALEN=48的虚拟地址结构，意味着在64位的虚拟地址中只有低48位被使用，高16位是闲置或者用于窗口实现的。
此模式下，页表在逻辑层面上形成一个包含$2^{36}$个页表条目的大数组。
地址转换是4步的过程，页表在物理内存中以三层的树状结构进行存储，这棵树的根节点是4096字节的页，其中包括512个PTE，每个PTE都记录树的下一层级页表项的物理地址。这些下一层的每个页表项的每个PTE都引用的树的最后一层中的512个PTE。再进行地址转换过程中，如果缺少必要的4个PTE中的任意一个，分页硬件会抛出以1个页面错误异常，由操作系统负责处理这一情况

由于在执行转换过程中，CPU需要在内存中遍历页面，不断从页面载入数据，非常的浪费效率。因此为了降低从PTE中获得页面的成本，采取将页面信息缓存在TLB中的方式。
每个PTE包含一些标志位，这些标志位起到了向分页硬件说明如何处理相应的虚拟地址。
### 页表项
![](doc/picture/Pasted%20image%2020240520184848.png)
avx-loongarch64 采用虚双页号的设计，每一个TLB表项都可以分为2个部分：比较部分和物理部分。
TLB表项的比较部分包括：
- 存在位(E)，1比特。为1时表示TLB表项非空，可以参与查找分配
- 地址空间标志(ASID)，10比特。用于区分不同进程中相同的虚拟地址，避免进程切换时清空整个TLB带来的性能损失。操作系统为每个进程分配了唯一的ASID，TLB在进行查找时除了比对地址信息一致，还要比对ASID信息
- 全局标志位(G)，1比特。当该位为1时，查找时不进行ASID是否一致性的检查。
- 页大小(PS)，6比特。仅在MTLB中出现，用于指定大页页表的页表项存放的页大小。数值是页大小的幂指数。
- **虚双页号**，(VALEN - 13)比特。在LA64下，每个页表存放相邻的一对奇偶相邻页表信息，所以TLB页表中存放虚页号的是系统中虚页号/2 的内容，即虚页号的最低位不需要存放在TLB中。查找TLB时根据被查找虚页号的最低位决定选择时奇数号页还是偶数号页。

物理部分，PPN表示物理页号，(PALEN-12)比特，其余页表转换信息包括：
- 有效位(V)，1比特。为1表示页表项有效并且被访问过。
- 脏位(D)，1比特。为1时表示页表项对应的地址范围内有脏数据。
- 不可读位(NR)，1比特。为1时表示该页表项所在的地址空间上不允许执行load操作。
- 不可执行位(NX)，1比特。为1表示该页表项所在的地址空间上不允许执行取指操作。
- 存储访问类型(MAT)，2比特。控制落在页表项所在地址空间上访存操作的存储访问类型。
- 特权等级(PLV)，2比特。
- 受限特权等级使能(RPLV)，1比特。页表项是否仅被对应特权等级的程序访问的控制位。为0时，该页表项可以被任何特权等级不低于PLV的程序访问；当RPLV=1时，该页表项可以被等级等于PLV的程序访问。

通常，avx-loongarch64 会将所有的物理内存映射到页表中，这样它就可以使用`load/store`指令读取和写入物理内存。

### 虚存管理函数
虚存的管理函数主要用于分页和内存映射，在模块`vm.c`中定义的函数主要执行内存分页、页表创建和管理，虚拟地址和物理地址之间的映射和反映等操作。
函数定义内容如下：
- `kminit()`：创建一个直接映射的页表用于内核。在函数中，首先给页表分配空间，使用无意义的数据做初始化。然后，建立内核与其他设备的映射，如UART寄存器，从而使内核通过映射的虚拟地址访问这些设备
- `kvminithart`：将硬件的页表寄存器设置为内核的页表，刷新页表。
- `walk()`：返回对于给定的虚拟地址的页表项的地址，如果参数`alloc = 1`则会为没有分配的虚拟地址分配页表
- `walkaddr()`：返回给定虚拟地址的物理地址，只工作在用户态下。
- `kvmmap()`：函数实现向内核页表添加一个映射，只在内核启动时调用。
- `kvmpa()`：用于将内核的虚拟地址转换为物理地址
- `mappages()`：为从传入虚拟地址`va`处创建页表项，这些页表项必须指向从`pa`开始的物理地址；允许`va`页不对齐。
- `vmunmap()`：这个函数负责取消从`va`开始的npages页的映射关系，根据参数`do_free`是否为真同时释放内存
- `uvminit()`：将用户的初始代码加载到页表的地址0处。
- `uvmalloc1()`：函数负责从`start`到`end`的虚拟地址分配PTE和物理内存，失败返回-1

以下是对页表的更精细化的操作：
- `freewalk`：这个函数遍历页表，递归地释放所有子页表
- `uvmfree()`：先释放用户内存，再释放页表项
- `uvmcopy`：复制父进程的页表项和物理内存到子进程的页表中
- `uvmclear`：将指定的虚拟地址的页表项标记为用户无法访问，设置特权级障碍
- `copyout()`：负责从内核复制数据到用户空间
- `copyout2()`：`copyout()`的简化版本，直接在虚拟地址空间操作
- `copyin()`：从用户空间复制数据到内核
- `copyin2()`：`copyin`的简化版本
- `copyinstr`：从用户空间复制一个字符串到内核
- `copyinstr2`：`copyinstr`的简化版本，直接在虚拟地址空间操作
- `proc_kpageytable`：初始化每个进程的内核页表
- `kfreewalk()`：释放页表的内核空间
- `kfreeuser()`：释放用户页表的内核空间，通过调用`kfreewalk()`实现
- `kvmfree()`：释放整个内核页表
- `experm`：改变制定虚拟地址的页表项的权限

页表的权限管理、地址空间管理、分页映射等功能就通过上述的函数模块实现。每个进程都具有独立的页表，用户与映射其虚拟地址空间到物理内存中。每个进程的用户内存从0开始，逐步增长到上界MAXUVA。
 
![](doc/picture/Pasted%20image%2020240521183010.png)

# 进程管理
进程管理的模块主要分为：初始化、进程调用、进程切换等。

![](doc/picture/pic_1.jpg)
## 进程控制块
操作系统使用进程控制块将运行中的程序进行封装，利于操作系统的管理。进程控制块的结构如下所示。进程控制块存储进程的状态，是内核对进程进行管理的基本单元，同时，控制块的丰富程度反映了操作系统的复杂程度、交互能力和调度性能。
```c
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  struct proc *parent;         // Parent process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID
  int uid;                     // Process User ID
  int gid;                     // Process Group ID
  int pgid;
  
  uint64 filelimit;
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  
  pagetable_t pagetable;       // User page table
  pagetable_t kpagetable;      // Kernel page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  int *exec_close;             // Open files
  struct dirent *cwd;          // Current directory
  char name[16];               // Process name (debugging)
  int tmask;                    // trace mask
  struct vma *vma;
  int ktime;
  int utime;
};
```


## 进程状态
进程状态定义如下：
```c
enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
```
各状态解释如下：
- `UNUSED`：表示进程控制块没有对应的进程
- `USED`：表示进程控制块存在对应的进程
- `SLEEPING`：进程由于等待资源等原因没有运行
- `RUNNABLE`：进程进入等待资源调度的环节
- `RUNNING`：表示进程正在运行
- `ZOMBIE`：进程被杀死，但是资源没有回收，处于”僵死“状态


## 进程控制
具体介绍进程的分配、初始化和调度等执行模块。

### 进程分配
在avx-loongarch64 中，使用`allocproc`函数分配新的进程：
- 寻找一个`UNUSED`的进程控制块，如果找到则跳转到`found`标签进行后续的**初始化操作**，如果没有，则返回`NULL` 
- 初始化进程控制块：如果找到了一个没有使用的进程控制块，先调用`allocpid()`函数分配进程号，初始化其虚拟内存地址为空，设置其内核时间和用户时间为1
- 分配`trapframe`页面：通过调用`kalloc()`函数，为该进程的`trapframe` 分配相应的内存空间；如果分配失败返回`NULL`
- 创建用户页表和内核页表：成功分配`trapframe`页面后，函数将创建一个空的用户页面和一个内核页表，如果任意的页表创建失败，函数返回`NULL`并清空分配空间
- 设置进程的内核堆栈
- 设置新的进程上下文，设置返回地址寄存器为`forkret()` 函数的地址，将堆栈指针设置为内核堆栈的顶部。新的进程将从`forkret()`函数开始执行

### 进程初始化
内核启动过程中，除此`init`过程，其他进程都是通过`fork()` 和 `exec()` 的方式加载的。
初始化的执行过程如下：
- 从进程控制块的数组中寻找一个空闲的块
- 页表映射：avx-loongarch64 采用PALEN=48的虚拟内存模型。在此步骤中，操作系统会为程序的每个段进行页表映射。

原始的`init`进入无限的进程调度循环中，其他程序创建和执行的步骤正是：
- fork：创建新的进程
- exec：调用执行程序

将新建进程的状态进程初始化，设置进程控制块的个状态设置为默认值，代码如下所示：
```c
static struct proc *allocproc(void) {
  struct proc *p;

  for (p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if (p->state == UNUSED) {
      goto found;
    } else {
      release(&p->lock);
    }
  }
  return NULL;

found:
  p->pid = allocpid();
  freemem_amount();
  printf("alloc proc:%d freemem_mount:%p\n", p->pid, freemem_amount());
  p->vma = NULL;
  p->filelimit = NOFILE;
  p->ktime = 1;
  p->utime = 1;
  p->uid = 0;
  p->gid = 0;
  p->pgid = 0;

  // 信号量

  if ((p->trapframe = (struct trapframe *)kalloc()) == NULL) {
    release(&p->lock);
    return NULL;
  // }
  // 用户页表和内核页表
  if ((p->pagetable = proc_pagetable(p)) == NULL ||
      (p->kpagetable = proc_pagetable(p)) == NULL) {
    freeproc(p);
    release(&p->lock);
    return NULL;
  }
  
  p->kstack = PROCVKSTACK(get_proc_addr_num(p));

  // p->exec_close = kalloc();
  // for (int fd = 0; fd < NOFILE; fd++)
  //   p->exec_close[fd] = 0;

  // Set up new context to start executing at forkret,
  // which returns to user space.
  memset(&p->context, 0, sizeof(p->context));

  // init 上下文和线程
  p->context.ra = (uint64)forkret;
  p->context.sp = p->kstack + KSTACKSIZE;

  return p;
  }
}
```

### 进程调度
目前，avx-loongarch系统的进程调度采用时间片均分的策略；所有进程不分优先级的在统一的队列中进行调度。
进程的调度是对cpu的占用，系统首先需要对cpu这一资源进行抽象：
```c
// Per-CPU state.
	struct cpu {
	struct proc *proc; // The process running on this cpu, or null.
	struct context context; // swtch() here to enter scheduler().
	int noff; // Depth of push_off() nesting.
	int intena; // Were interrupts enabled before push_off()?
};
```

其中作为资源抢占和调度保存的基本单位，`proc`和 上下文字段是最重要的。`proc`指向在当前cpu上执行的进程，context的字段保存进程切换时的上下文。context的定义如下所示：
```c
typedef struct context {
  uint64 ra; //0
  uint64 sp; //8

  // callee-saved
  uint64 s0;
  uint64 s1;
  uint64 s2;
  uint64 s3;
  uint64 s4;
  uint64 s5;
  uint64 s6;
  uint64 s7;
  uint64 s8;
  
  uint64 fp;
}context;

```

context结构体用于保存进程上下文信息，以便进程在下一次投入运行时从恢复上下文。当系统需要进行进程切换时，它会扫描所有进程，寻找状态为RUNNABLE 的进程。
这一调度过程是通过`yield`和`scheduler`函数联合实现的。

`yield`是对cpu资源的放弃，是将要退出的进程执行的最后一步：
```c
// // Give up the CPU for one scheduling round.

void yield(void) {
	struct proc *p = myproc();
	acquire(&p->lock);
	printf("pid %d yield\n, era: %p", p->pid, p->trapframe->era);
	p->state = RUNNABLE;
	// todo：线程部分
	// p->main_thread->state = t_RUNNABLE;
	// 行调度，以进程（线程）为基本单位
	sched();
	release(&p->lock);
}
```

一般是由调度函数调用来切换进程，`scheduler`的执行是：
- 从进程列表中选择一个状态为RUNNABLE的进程；获取进程后，获得该进程的锁防止其他进程同时修改**进程列表**
- 这个处于等待状态的进程的状态被修改为`RUNNING`，并且将其设置为当前CPU正在运行的进程。此时，函数将页表切换为当前进程的内核页表，更新地址空间；
- 然后，函数执行`swtch`操作进行上下文的切换。
- 在进程运行结束后，CPU会跳回`scheduler`函数中，并且将页表切换会内核页表，同时刷新地址空间。
- 最后，CPU将正在运行的进程状态设置为0,表示此时CPU中没有正在运行的进程，然后释放进程的锁，等待下次的进程调度过程

### 进程释放
进程释放过程是通过调用`freeproc()`函数实现的，该函数的实现如下：
```c
static void freeproc(struct proc *p) {
  if (p->trapframe)
    kfree((void *)p->trapframe);
    kfree((void *)p->exec_close);
  p->trapframe = 0;
  if (p->kpagetable) {
    kvmfree(p->kpagetable, 1, p);
  }

  p->kpagetable = 0;
  if (p->pagetable) {
    free_vma_list(p);
    proc_freepagetable(p->pagetable, p->sz);
  }
  // TODO: free threads
  freemem_amount();
  printf("free proc : %d freemem_mount:%p\n",p->pid, freemem_amount());
  p->pagetable = 0;
  p->vma = NULL;
  p->sz = 0;
  p->pid = 0;

  p->parent = 0;
  p->name[0] = 0;
  p->chan = 0;
  p->killed = 0;
  p->xstate = 0;
  p->state = UNUSED;
}
```

下面解释该函数各步骤的实现过程：
- 释放`trapframe`：首先，如果trapframe存在则释放其占用的内存，然后将`trapframe`字段设置为0；
- 释放内核页表和用户页表
- 清空进程控制块的其他字段
- 设置进程状态为`UNUSED`，表示该进程控制块已经被清空，可以用于分配新的进程。

通过这样的步骤，`freeproc()`函数实现了对进程资源的回收，这些资源包括内存资源和进程控制块的各种字段。

# 系统调用的设计实现
> by wty

## 系统调用的流程
使用`ecall()` 指令负责系统调用。在用户态，我们将系统调用的参数保存在a0、a1寄存器中，使用a7寄存器保存系统调用号。当执行`ecall()`时，会主动触发一次异常（LA64下中断均实现为异常），并进入到异常处理流程中。在系统初始化的阶段，我们准备stvec寄存器保存“中断向量”。
![](doc/picture/pic_2.drawio.png)

在用户程序触发异常后，首先要将当前用户程序的表示当前所有寄存器的数据结构保存在另一个指定的`trapframe`结构中，然后进入内核操作。
为了处理系统调用，我们设计了一个函数指针数组，将对应系统调用号要执行的函数保存在对应的数组位值。通过系统调用号调用对应的函数，我们能够执行对应的系统调用操作。这样的操作使得系统可以根据不同的系统调用号来调用相应的功能函数，实现了系统调用的**灵活性和扩展性**。

## 一些系统调用的实现
### yield() 系统调用
`yield()`用于线程调度，主要功能是让出内核的进程调度，使得等待队列的第一个进程进入运行状态(`RUNNING`)。在异常处理程序结束后，内核在`usertrap()`中调用了`yield()`函数：
- 调用`schd`函数进入调度
- 保存当前的上下文保存在`p->context`中，然后切换到先前cpu调度器上的上下文 

在进程切换的部分，已经对`yield()`函数有所提及，此处不再赘述其代码。`yield()`函数首先获得进程的锁，防止进程在两个CPU核上运行，而一个进程只有一个内核栈，导致两个CPU核在同一个栈上运行代码。

然后，`yield()`函数将进程的状态改为`RUNNABLE`，表示当前进程要让出CPU然后切换到调度器进行调度。

### wait()系统调用
`wait()`用于等待子进程运行结束，主要用于内核需要杀死父进程时，需要等待该父进程的所有子进程都推出，才能结束父进程。子进程需要由父进程释放资源，否则需要为子进程寻找继父来释放资源。`wait()`函数传入的参数是一个指针类型，将子进程中`ZOMBIE`状态的进程的信息存放在该指针指向的地址中。

`wait()` 的实现比较简单，分别通过判断是否存在子进程实现：
![](doc/picture/pic_3.drawio.png)

- 首先遍历查看有无子进程，如果没有子进程则直接退出
- 如果有子进程，等待当前子进程僵死后释放资源；
- 如果没有僵死的子进程，则父进程陷入睡眠(SLEEPING)，直到子进程退出调用`exit()`唤醒父进程。

### read()系统调用
`read()`用于操作系统的输入功能，该系统调用负责从指定的文件描述符中读取内容。
- `fd`：文件描述符
- `buf`：读取文件使用的缓冲区
- `count`：将要读取的字节数

根据不同的文件描述符，操作系统可以处理`PIPE`、`DEVICE`和`ENTRY`的输入。
对于设备，操作系统使用`IOCSR`控制寄存器控制数据的流入和流出，同时，avx-loongarch64还有`devsw`的结构题数组用于维护各设备的IO情况。

### mmap()系统调用
`mmap()`用于将文件或者设备，主要是外存映射到内存中，便于内核通过访问虚拟地址直接访问外部设备。下面是`mmap()`模块的传入参数：
- `start`：表示映射到内存的起始位置，通过传入参数指定虚拟的起始地址；如果传入参数为NULL，则由系统自动分配一个可用的地址
- `len`：指定映射区域的长度。
- `prot`：指定映射区域的内存保护方式，指定进程对映射区域的访问权限。常见的权限有`PROT_WRITE`表示可写，用`PROT_READ`表示可读。
- `flags`：映射是否与其他进程共享的标志。
- `fd`：文件的句柄，通过此**文件描述符**确认要映射的文件
- `off`：文件的偏移量，表示从文件的哪个位置开始映射。

首先，函数获取当前文件的指针，并进行参数检查。如果文件描述符等参数非法，返回-1表示参数错误；然后，定义一个**权限变量**`perm`初始化权限为用户级别的权限，即`perm = PTE_PLV`。然后将权限和保护方式`prot`的内容合并，如果包含`PROT_WRITE`，则在`perm`中加入`PTE_W`和`PTE_D`标志表示访问。

接着，根据文件描述符（fd）获取当前打开文件（OFILES）的文件结构体指针。如果`fd`返回-1表示文件不存在。
调用`alloc_mmap_vma`函数给当前新进程分配虚拟内存空间（`vma`）的结构体，并传递相关参数。该函数在进程的虚拟内存区域创建一个新的映射区域，并返回`vma`结构体的指针。同理，如果分配失败则返回-1。
更新起始地址为分配的`vma` 的起始地址`vma->addr`。如果文件存在，那么计算mmap的大小，即使用映射文件的大小减去偏移量。如果`len`小于这个大小，则将`mmap_size`设置为`len`，保证不超过`len`的大小。然后将文件的偏移设置为给定的偏移量。

下一步，计算`mmap_size`对页面大小求余的结果，以及需要映射的页面数量。定义一个新的虚拟地址变量`va`，将其初始化为起始地址。在循环体中通过调用`experm()`函数将虚拟地址`va`映射到物理地址`pa`中，修改地址的权限。
在循环过程中，根据当前页是否为最后一页执行不同的操作：
- 如果不是最后一页，调用`fileread()`函数从文件中读取页面大小的数据写入`va`指向的内存中
- 否则调用`fileread()`调用剩下页面大小的数据，写入此时`va`指向的虚拟地址的内存，然后将剩余不到整页的空间清空。

循环结束后，调用`fileup`对文件结构体增加其引用计数，确保在`mmap`映射时文件不会关闭。下面是`alloc_mmap_vma()`函数的实现代码：
```c
struct vma *alloc_mmap_vma(struct proc *p, int flags, uint64 addr, uint64 sz,
                           int perm, int fd, uint64 f_off) {
  struct vma *vma = NULL;
  struct vma *find_vma = find_mmap_vma(p->vma);
  if (0 == addr && sz < find_vma->addr) {
    addr = PGROUNDDOWN(find_vma->addr - sz);
  }
  vma = alloc_vma(p, MMAP, addr, sz, perm, 1, NULL);
  if (NULL == vma) {
    printf("alloc_mmap_vma: alloc_vma failed\n");
    return NULL;
  }
  vma->fd = fd;
  vma->f_off = f_off;

  return vma;
}
```

`vma`结构体的实现如下所示。这个结构体用于表示进程的一个虚拟内存区域，包括该区域的类型、起始地址、结束地址、大小和权限设置等信息。`vma`之间通过双向链表进行链接。

```c
struct vma {
	enum segtype type; //分配的vma的作用是干什么
	int perm; //这个vma的权限是什么
	
	uint64 addr; //vma映射的内存地址是什么
	uint64 sz; //vma映射的大小是什么
	uint64 end; //vma映射的结束地址
	int flags; // vma进程的权限设置
	int fd;
	uint64 f_off;
	struct vma *prev; //链表结构，按照addr排序
	struct vma *next;
};
```

`vma`的相关函数实现在`vma.c`的模块中。函数`vma_init()`用于初始化进程的`vma`，返回指向`vma`结构体的指针。它接受一个指向进程结构体的指针作为参数，在函数内部，创建并分配一个vma结构体。然后将这个结构体与进程关联，创建一个初始的MMAP类型的vma；起始地址设置为`USER_MMAP_START`，大小为0。
函数`alloc_vma()`用于分配一个vma并将其插入到进程的vma链表中。它传入进程指针、vma类型、vma的起始地址addr、大小sz等作为参数。函数首先根据地址和大小检查是否已经存在冲突的vma，然后分配一个vma结构体。根据传入参数`alloc`的值进行内核分配或者映射。最后，根据传入参数为分配的vma结构体的每个字段赋值，插入到
该进程的vma链表中。
函数`find_mmap_vma`用于在给定的vma链表中查找类型为MMAP的vma，实现上为遍历链表。如果找到，返回该vma的指针；否则返回NULL。

### clone()系统调用
使用`clone()`创建一个子进程，用于完善已经实现的`fork()`函数。该函数传入`flags`（创建标志）、`stack`（指定的栈），父进程`id`和子进程的`sid`。
在`clone()`系统调用中，可以指定一个新的用户栈空间，接受一个预先分配的用户空间爱你的虚拟地址作为用户栈，然后改变子进程的`sp`字段为此指定的用户栈地址。

### times()系统调用
进程使用`p->utime`和`p->ktime`分别保存当前的用户态运行时间和内核态运行时间的数据。`times()`用于返回进程时间，输入参数为`tms`结构体，返回进程已经过去的tick数。其结构体和实现如下所示：
```c
struct tms
{
	long tms_utime;
	long tms_stime;
	long tms_cutime;
	long tms_cstime;
};

// 进程的时间统计信息
uint64 sys_times() {
  struct tms ptms;
  uint64 utms;
  argaddr(0, &utms);
  ptms.tms_utime = myproc()->utime;
  ptms.tms_stime = myproc()->ktime;
  ptms.tms_cstime = 1;
  ptms.tms_cutime = 1;
  struct proc *p;
  for (p = proc; p < proc + NPROC; p++) {
    acquire(&p->lock);
    if (p->parent == myproc()) {
      ptms.tms_cutime += p->utime;
      ptms.tms_cstime += p->ktime;
    }
    release(&p->lock);
  }
  copyout(myproc()->pagetable, utms, (char *)&ptms, sizeof(ptms));
  return 0;
}
```