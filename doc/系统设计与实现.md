> by wty
# Loongarch64虚地址管理方式
LA64物理地址长度PALEN长度通过CSR定义，内存物理地址范围在$0 \sim 2^{PALEAN}$之间，PALEN不大于60。
以PALEN = 48 的情况为例， 此时虚拟页表如下：

![](doc/picture/Pasted%20image%2020240520184848.png)
LA64采用虚双页号的设计，每一个TLB表项都可以分为2个部分：比较部分和物理部分。
TLB表项的比较部分包括：
- 存在位(E)，1比特。为1时表示TLB表项非空，可以参与查找分配
- 地址空间标志(ASID)，10比特。用于区分不同进程中相同的虚拟地址，避免进程切换时清空整个TLB带来的性能损失。操作系统为每个进程分配了唯一的ASID，TLB在进行查找时除了比对地址信息一致，还要比对ASID信息
- 全局标志位(G)，1比特。当该位为1时，查找时不进行ASID是否一致性的检查。
- 页大小(PS)，6比特。仅在MTLB中出现，用于指定大页页表的页表项存放的页大小。数值是页大小的幂指数。
- **虚双页号**，(VALEN - 13)比特。在LA64下，每个页表存放相邻的一对奇偶相邻页表信息，所以TLB页表中存放虚页号的是系统中虚页号/2 的内容，即虚页号的最低位不需要存放在TLB中。查找TLB时根据被查找虚页号的最低位决定选择时奇数号页还是偶数号页。

物理部分，PPN表示物理页号，(PALEN-12)比特，其余页表转换信息包括：
- 有效位(V)，1比特。为1表示页表项有效并且被访问过。
- 脏位(D)，1比特。为1时表示页表项对应的地址范围内有脏数据。
- 不可读位(NR)，1比特。为1时表示该页表项所在的地址空间上不允许执行load操作。
- 不可执行位(NX)，1比特。为1表示该页表项所在的地址空间上不允许执行取指操作。
- 存储访问类型(MAT)，2比特。控制落在页表项所在地址空间上访存操作的存储访问类型。
- 特权等级(PLV)，2比特。
- 受限特权等级使能(RPLV)，1比特。页表项是否仅被对应特权等级的程序访问的控制位。为0时，该页表项可以被任何特权等级不低于PLV的程序访问；当RPLV=1时，该页表项可以被等级等于PLV的程序访问。

# 地址空间布局


# 内存管理
## 物理内存管理
实现程序内存空间的访问，首要的是实现物理内存空间的分配。avx-Loongarch64 使用kalloc.c 文件负责物理内存的管理，包括内存的释放，访问上锁的控制以及内存的初始化等。
内存分配采用空闲链表的方式，空闲的页（每页大小为4096B）采用`struct run` 结构体负责页的分配与释放；该结构体实现的就是单向的空闲链表，链表的每个结点表示1个实际物理页。
其他的数据结构还有：
- `kmem`：在kalloc.c 模块中唯一定义的全局变量，用于访问空闲链表`freelist`，该链表使用上文`struct run` 结构实现。`kmem` 同时维护访问内存的自旋锁`spinlock`，以及剩余空闲页数`npage`

```c
struct {
	struct spinlock lock;
	struct run *freelist;
	uint64 npage;
} kmem;
```

内核启动，调用初始化函数kminit。它首先初始化kmem中的自旋锁，然后调用freerange() 函数将内核结束地址kernel_end 到物理内存上限的RAMSTOP之间的所有物理内存页添加到空闲列表中：
```c
void kinit() {
	initlock(&kmem.lock, "kmem");
	kmem.freelist = 0;
	kmem.npage = 0;
	freerange(kernel_end, (void *)RAMSTOP);
	printf("kernel_end: %p, RAMSTOP: %p\n", kernel_end, (void *)RAMSTOP);
}
```

`freerange()`用于将一段物理内存地址范围内的所有物理内存释放，然后加入到空闲链表中。它首先将起始地址向上取整到页的边界，然后从起始地址开始，每次增加1个页的大小，然后依次释放每个物理内存页。

`kfree()`函数用于释放1个物理的内存页。函数首先检查传入物理地址的合法性，检查通过则清空物理页的内容，填充垃圾字节，调用`run` 结构体将空页加入到空闲链表中。
`kalloc()`负责分配1个物理的内存页。如果空闲链表为空，返回`NULL` 表示分配失败；否则取出链表的头结点，清空该页的内容后返回。
`freemem_amount()` 返回当前空闲物理内存容量，返回方式为空闲页总量乘上每页的固定字节数（4096字节），返回值为物理内存的字节数。

## 虚拟内存管理


# 进程管理
进程管理的模块主要分为：初始化、进程调用、进程切换等。
![](doc/picture/进程关系.png)
## 进程控制块
操作系统使用进程控制块将运行中的程序进行封装，利于操作系统的管理。进程控制块的结构如下所示。进程控制块存储进程的状态，是内核对进程进行管理的基本单元，同时，控制块的丰富程度反映了操作系统的复杂程度、交互能力和调度性能。
```c
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  struct proc *parent;         // Parent process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID
  int uid;                     // Process User ID
  int gid;                     // Process Group ID
  int pgid;
  
  uint64 filelimit;
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  
  pagetable_t pagetable;       // User page table
  pagetable_t kpagetable;      // Kernel page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  int *exec_close;             // Open files
  struct dirent *cwd;          // Current directory
  char name[16];               // Process name (debugging)
  int tmask;                    // trace mask
  struct vma *vma;
  int ktime;
  int utime;
};
```

## 进程状态
进程状态定义如下：
```c
enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
```
各状态解释如下：
- `UNUSED`：表示进程控制块没有对应的进程
- `USED`：表示进程控制块存在对应的进程
- `SLEEPING`：进程由于等待资源等原因没有运行
- `RUNNABLE`：进程进入等待资源调度的环节
- `RUNNING`：表示进程正在运行
- `ZOMBIE`：进程被杀死，但是资源没有回收，处于”僵死“状态


## 进程控制
具体介绍进程的分配、初始化和调度等执行模块。

### 进程分配
在avx-loongarch64 中，使用`allocproc`函数分配新的进程：
- 寻找一个`UNUSED`的进程控制块，如果找到则跳转到`found`标签进行后续的**初始化操作**，如果没有，则返回`NULL` 
- 初始化进程控制块：如果找到了一个没有使用的进程控制块，先调用`allocpid()`函数分配进程号，初始化其虚拟内存地址为空，设置其内核时间和用户时间为1
- 分配`trapframe`页面：通过调用`kalloc()`函数，为该进程的`trapframe` 分配相应的内存空间；如果分配失败返回`NULL`
- 创建用户页表和内核页表：成功分配`trapframe`页面后，函数将创建一个空的用户页面和一个内核页表，如果任意的页表创建失败，函数返回`NULL`并清空分配空间
- 设置进程的内核堆栈
- 设置新的进程上下文，设置返回地址寄存器为`forkret()` 函数的地址，将堆栈指针设置为内核堆栈的顶部。新的进程将从`forkret()`函数开始执行

### 进程初始化
内核启动过程中，除此`init`过程，其他进程都是通过`fork()` 和 `exec()` 的方式加载的。
初始化的执行过程如下：
- 从进程控制块的数组中寻找一个空闲的块
- 页表映射：avx-loongarch64 采用PALEN=48的虚拟内存模型。在此步骤中，操作系统会为程序的每个段进行页表映射。

原始的`init`进入无限的进程调度循环中，其他程序创建和执行的步骤正是：
- fork：创建新的进程
- exec：调用执行程序

将新建进程的状态进程初始化，设置进程控制块的个状态设置为默认值，代码如下所示：
```c
static struct proc *allocproc(void) {
  struct proc *p;

  for (p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if (p->state == UNUSED) {
      goto found;
    } else {
      release(&p->lock);
    }
  }
  return NULL;

found:
  p->pid = allocpid();
  freemem_amount();
  printf("alloc proc:%d freemem_mount:%p\n", p->pid, freemem_amount());
  p->vma = NULL;
  p->filelimit = NOFILE;
  p->ktime = 1;
  p->utime = 1;
  p->uid = 0;
  p->gid = 0;
  p->pgid = 0;

  // 信号量

  if ((p->trapframe = (struct trapframe *)kalloc()) == NULL) {
    release(&p->lock);
    return NULL;
  // }
  // 用户页表和内核页表
  if ((p->pagetable = proc_pagetable(p)) == NULL ||
      (p->kpagetable = proc_pagetable(p)) == NULL) {
    freeproc(p);
    release(&p->lock);
    return NULL;
  }
  
  p->kstack = PROCVKSTACK(get_proc_addr_num(p));

  // p->exec_close = kalloc();
  // for (int fd = 0; fd < NOFILE; fd++)
  //   p->exec_close[fd] = 0;

  // Set up new context to start executing at forkret,
  // which returns to user space.
  memset(&p->context, 0, sizeof(p->context));

  // init 上下文和线程
  p->context.ra = (uint64)forkret;
  p->context.sp = p->kstack + KSTACKSIZE;

  return p;
  }
}
```

### 进程调度
目前，avx-loongarch系统的进程调度采用时间片均分的策略；所有进程不分优先级的在统一的队列中进行调度。
进程的调度是对cpu的占用，系统首先需要对cpu这一资源进行抽象：
```c
// Per-CPU state.
	struct cpu {
	struct proc *proc; // The process running on this cpu, or null.
	struct context context; // swtch() here to enter scheduler().
	int noff; // Depth of push_off() nesting.
	int intena; // Were interrupts enabled before push_off()?
};
```

其中作为资源抢占和调度保存的基本单位，`proc`和 上下文字段是最重要的。`proc`指向在当前cpu上执行的进程，context的字段保存进程切换时的上下文。context的定义如下所示：
```c
typedef struct context {
  uint64 ra; //0
  uint64 sp; //8

  // callee-saved
  uint64 s0;
  uint64 s1;
  uint64 s2;
  uint64 s3;
  uint64 s4;
  uint64 s5;
  uint64 s6;
  uint64 s7;
  uint64 s8;
  
  uint64 fp;
}context;

```

context结构体用于保存进程上下文信息，以便进程在下一次投入运行时从恢复上下文。当系统需要进行进程切换时，它会扫描所有进程，寻找状态为RUNNABLE 的进程。
这一调度过程是通过`yield`和`scheduler`函数联合实现的。

`yield`是对cpu资源的放弃，是将要退出的进程执行的最后一步：
```c
// // Give up the CPU for one scheduling round.

void yield(void) {
	struct proc *p = myproc();
	acquire(&p->lock);
	printf("pid %d yield\n, era: %p", p->pid, p->trapframe->era);
	p->state = RUNNABLE;
	// todo：线程部分
	// p->main_thread->state = t_RUNNABLE;
	// 行调度，以进程（线程）为基本单位
	sched();
	release(&p->lock);
}
```

一般是由调度函数调用来切换进程，`scheduler`的执行是：
- 从进程列表中选择一个状态为RUNNABLE的进程；获取进程后，获得该进程的锁防止其他进程同时修改**进程列表**
- 这个处于等待状态的进程的状态被修改为`RUNNING`，并且将其设置为当前CPU正在运行的进程。此时，函数将页表切换为当前进程的内核页表，更新地址空间；
- 然后，函数执行`swtch`操作进行上下文的切换。
- 在进程运行结束后，CPU会跳回`scheduler`函数中，并且将页表切换会内核页表，同时刷新地址空间。
- 最后，CPU将正在运行的进程状态设置为0,表示此时CPU中没有正在运行的进程，然后释放进程的锁，等待下次的进程调度过程

### 进程释放
进程释放过程是通过调用`freeproc()`函数实现的，该函数的实现如下：
```c
static void freeproc(struct proc *p) {
  if (p->trapframe)
    kfree((void *)p->trapframe);
    kfree((void *)p->exec_close);
  p->trapframe = 0;
  if (p->kpagetable) {
    kvmfree(p->kpagetable, 1, p);
  }

  p->kpagetable = 0;
  if (p->pagetable) {
    free_vma_list(p);
    proc_freepagetable(p->pagetable, p->sz);
  }
  // TODO: free threads
  freemem_amount();
  printf("free proc : %d freemem_mount:%p\n",p->pid, freemem_amount());
  p->pagetable = 0;
  p->vma = NULL;
  p->sz = 0;
  p->pid = 0;

  p->parent = 0;
  p->name[0] = 0;
  p->chan = 0;
  p->killed = 0;
  p->xstate = 0;
  p->state = UNUSED;
}
```

下面解释该函数各步骤的实现过程：
- 释放`trapframe`：首先，如果trapframe存在则释放其占用的内存，然后将`trapframe`字段设置为0；
- 释放内核页表和用户页表
- 清空进程控制块的其他字段
- 设置进程状态为`UNUSED`，表示该进程控制块已经被清空，可以用于分配新的进程。

通过这样的步骤，`freeproc()`函数实现了对进程资源的回收，这些资源包括内存资源和进程控制块的各种字段。
